exports["NATS"] =
/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./lib/nats.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./lib/crypto.js":
/*!***********************!*\
  !*** ./lib/crypto.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ./env */ \"./lib/env.js\");\n\nif (env.isNode()) {\n  module.exports = __webpack_require__(/*! crypto */ \"crypto\");\n}\nelse {\n  var crypto = window.crypto || window.msCrypto;\n\n  exports.randomBytes = function(size, cb) {\n    var buf = new Uint8Array(size);\n    if (size > 0) {\n      crypto.getRandomValues(buf);\n    }\n    return buf;\n  };\n}\n\n\n\n\n//# sourceURL=webpack://NATS/./lib/crypto.js?");

/***/ }),

/***/ "./lib/env.js":
/*!********************!*\
  !*** ./lib/env.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = {\n  isNode: function() {\n    return new Function('try { return this === global; } catch(e) { return false; }');\n  }\n};\n\n\n//# sourceURL=webpack://NATS/./lib/env.js?");

/***/ }),

/***/ "./lib/nats.js":
/*!*********************!*\
  !*** ./lib/nats.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Copyright 2013-2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* jslint node: true */\n\n\n/**\n * Module Dependencies\n */\nvar net    = __webpack_require__(/*! ./net */ \"./lib/net.js\"),\n    tls    = __webpack_require__(/*! ./tls */ \"./lib/tls.js\"),\n    url    = __webpack_require__(/*! url */ \"url\"),\n    util   = __webpack_require__(/*! util */ \"util\"),\n    events = __webpack_require__(/*! events */ \"events\"),\n    nuid   = __webpack_require__(/*! ./nuid */ \"./lib/nuid.js\");\n\n/**\n * Constants\n */\nvar VERSION = '1.0.1',\n\n    DEFAULT_PORT = 4222,\n    DEFAULT_PRE = 'nats://localhost:',\n    DEFAULT_URI = DEFAULT_PRE + DEFAULT_PORT,\n\n    MAX_CONTROL_LINE_SIZE = 1024,\n\n    // Parser state\n    AWAITING_CONTROL = 0,\n    AWAITING_MSG_PAYLOAD = 1,\n\n    // Reconnect Parameters, 2 sec wait, 10 tries\n    DEFAULT_RECONNECT_TIME_WAIT = 2 * 1000,\n    DEFAULT_MAX_RECONNECT_ATTEMPTS = 10,\n\n    // Ping interval\n    DEFAULT_PING_INTERVAL = 2 * 60 * 1000, // 2 minutes\n    DEFAULT_MAX_PING_OUT = 2,\n\n    // Protocol\n    //CONTROL_LINE = /^(.*)\\r\\n/, // TODO: remove / never used\n\n    MSG = /^MSG\\s+([^\\s\\r\\n]+)\\s+([^\\s\\r\\n]+)\\s+(([^\\s\\r\\n]+)[^\\S\\r\\n]+)?(\\d+)\\r\\n/i,\n    OK = /^\\+OK\\s*\\r\\n/i,\n    ERR = /^-ERR\\s+('.+')?\\r\\n/i,\n    PING = /^PING\\r\\n/i,\n    PONG = /^PONG\\r\\n/i,\n    INFO = /^INFO\\s+([^\\r\\n]+)\\r\\n/i,\n    SUBRE = /^SUB\\s+([^\\r\\n]+)\\r\\n/i,\n\n    CR_LF = '\\r\\n',\n    CR_LF_LEN = CR_LF.length,\n    EMPTY = '',\n    SPC = ' ',\n\n    // Protocol\n    //PUB     = 'PUB', // TODO: remove / never used\n    SUB = 'SUB',\n    UNSUB = 'UNSUB',\n    CONNECT = 'CONNECT',\n\n    // Responses\n    PING_REQUEST = 'PING' + CR_LF,\n    PONG_RESPONSE = 'PONG' + CR_LF,\n\n    // Errors\n    BAD_AUTHENTICATION = 'BAD_AUTHENTICATION',\n    BAD_AUTHENTICATION_MSG = 'User and Token can not both be provided',\n    BAD_JSON = 'BAD_JSON',\n    BAD_JSON_MSG = 'Message should be a non-circular JSON-serializable value',\n    BAD_MSG = 'BAD_MSG',\n    BAD_MSG_MSG = 'Message can\\'t be a function',\n    BAD_REPLY = 'BAD_REPLY',\n    BAD_REPLY_MSG = 'Reply can\\'t be a function',\n    BAD_SUBJECT = 'BAD_SUBJECT',\n    BAD_SUBJECT_MSG = 'Subject must be supplied',\n    CLIENT_CERT_REQ = 'CLIENT_CERT_REQ',\n    CLIENT_CERT_REQ_MSG = 'Server requires a client certificate.',\n    CONN_CLOSED = 'CONN_CLOSED',\n    CONN_CLOSED_MSG = 'Connection closed',\n    CONN_ERR = 'CONN_ERR',\n    CONN_ERR_MSG_PREFIX = 'Could not connect to server: ',\n    INVALID_ENCODING = 'INVALID_ENCODING',\n    INVALID_ENCODING_MSG_PREFIX = 'Invalid Encoding:',\n    NATS_PROTOCOL_ERR = 'NATS_PROTOCOL_ERR',\n    NON_SECURE_CONN_REQ = 'NON_SECURE_CONN_REQ',\n    NON_SECURE_CONN_REQ_MSG = 'Server does not support a secure connection.',\n    PERMISSIONS_ERR = \"permissions violation\",\n    REQ_TIMEOUT = 'REQ_TIMEOUT',\n    REQ_TIMEOUT_MSG_PREFIX = 'The request timed out for subscription id: ',\n    SECURE_CONN_REQ = 'SECURE_CONN_REQ',\n    SECURE_CONN_REQ_MSG = 'Server requires a secure connection.',\n    STALE_CONNECTION_ERR = \"stale connection\",\n\n    // Pedantic Mode support\n    //Q_SUB = /^([^\\.\\*>\\s]+|>$|\\*)(\\.([^\\.\\*>\\s]+|>$|\\*))*$/, // TODO: remove / never used\n    //Q_SUB_NO_WC = /^([^\\.\\*>\\s]+)(\\.([^\\.\\*>\\s]+))*$/, // TODO: remove / never used\n\n    FLUSH_THRESHOLD = 65536;\n\n/**\n * @param {String} message\n * @param {String} code\n * @param {Error} [chainedError]\n * @constructor\n *\n * @api private\n */\nfunction NatsError(message, code, chainedError) {\n    Error.captureStackTrace(this, this.constructor);\n    this.name = this.constructor.name;\n    this.message = message;\n    this.code = code;\n    this.chainedError = chainedError;\n}\n\nutil.inherits(NatsError, Error);\nexports.NatsError = NatsError;\n\n/**\n * Library Version\n */\nexports.version = VERSION;\n\n/**\n * Error codes\n */\nexports.BAD_SUBJECT = BAD_SUBJECT;\nexports.BAD_MSG = BAD_MSG;\nexports.BAD_REPLY = BAD_REPLY;\nexports.CONN_CLOSED = CONN_CLOSED;\nexports.BAD_JSON = BAD_JSON;\nexports.BAD_AUTHENTICATION = BAD_AUTHENTICATION;\nexports.INVALID_ENCODING = INVALID_ENCODING;\nexports.SECURE_CONN_REQ = SECURE_CONN_REQ;\nexports.NON_SECURE_CONN_REQ = NON_SECURE_CONN_REQ;\nexports.CLIENT_CERT_REQ = CLIENT_CERT_REQ;\nexports.NATS_PROTOCOL_ERR = NATS_PROTOCOL_ERR;\nexports.REQ_TIMEOUT = REQ_TIMEOUT;\n\n\n/**\n * Create a properly formatted inbox subject.\n *\n * @api public\n */\nvar createInbox = exports.createInbox = function() {\n    return (\"_INBOX.\" + nuid.next());\n};\n\n/**\n * Initialize a client with the appropriate options.\n *\n * @param {Mixed} [opts]\n * @api public\n */\nfunction Client(opts) {\n    events.EventEmitter.call(this);\n    this.parseOptions(opts);\n    this.initState();\n    this.createConnection();\n}\n\n/**\n * Connect to a nats-server and return the client.\n * Argument can be a url, or an object with a 'url'\n * property and additional options.\n *\n * @params {Mixed} [opts]\n *\n * @api public\n */\nexports.connect = function(opts) {\n    return new Client(opts);\n};\n\n/**\n * Connected clients are event emitters.\n */\nutil.inherits(Client, events.EventEmitter);\n\n/**\n * Allow createInbox to be called on a client.\n *\n * @api public\n */\nClient.prototype.createInbox = createInbox;\n\nClient.prototype.assignOption = function(opts, prop, assign) {\n    if (assign === undefined) {\n        assign = prop;\n    }\n    if (opts[prop] !== undefined) {\n        this.options[assign] = opts[prop];\n    }\n};\n\nfunction shuffle(array) {\n    for (var i = array.length - 1; i > 0; i--) {\n        var j = Math.floor(Math.random() * (i + 1));\n        var temp = array[i];\n        array[i] = array[j];\n        array[j] = temp;\n    }\n    return array;\n}\n\n/**\n * Parse the conctructor/connect options.\n *\n * @param {Mixed} [opts]\n * @api private\n */\nClient.prototype.parseOptions = function(opts) {\n    var options = this.options = {\n        verbose: false,\n        pedantic: false,\n        reconnect: true,\n        maxReconnectAttempts: DEFAULT_MAX_RECONNECT_ATTEMPTS,\n        reconnectTimeWait: DEFAULT_RECONNECT_TIME_WAIT,\n        encoding: 'utf8',\n        tls: false,\n        waitOnFirstConnect: false,\n        pingInterval: DEFAULT_PING_INTERVAL,\n        maxPingOut: DEFAULT_MAX_PING_OUT,\n        useOldRequestStyle: false\n    };\n\n    if (undefined === opts) {\n        options.url = DEFAULT_URI;\n    } else if ('number' === typeof opts) {\n        options.url = DEFAULT_PRE + opts;\n    } else if ('string' === typeof opts) {\n        options.url = opts;\n    } else if ('object' === typeof opts) {\n        if (opts.port !== undefined) {\n            options.url = DEFAULT_PRE + opts.port;\n        }\n        // Pull out various options here\n        this.assignOption(opts, 'url');\n        this.assignOption(opts, 'uri', 'url');\n        this.assignOption(opts, 'user');\n        this.assignOption(opts, 'pass');\n        this.assignOption(opts, 'token');\n        this.assignOption(opts, 'password', 'pass');\n        this.assignOption(opts, 'verbose');\n        this.assignOption(opts, 'pedantic');\n        this.assignOption(opts, 'reconnect');\n        this.assignOption(opts, 'maxReconnectAttempts');\n        this.assignOption(opts, 'reconnectTimeWait');\n        this.assignOption(opts, 'servers');\n        this.assignOption(opts, 'urls', 'servers');\n        this.assignOption(opts, 'noRandomize');\n        this.assignOption(opts, 'NoRandomize', 'noRandomize');\n        this.assignOption(opts, 'dontRandomize', 'noRandomize');\n        this.assignOption(opts, 'encoding');\n        this.assignOption(opts, 'tls');\n        this.assignOption(opts, 'secure', 'tls');\n        this.assignOption(opts, 'name');\n        this.assignOption(opts, 'client', 'name');\n        this.assignOption(opts, 'yieldTime');\n        this.assignOption(opts, 'waitOnFirstConnect');\n        this.assignOption(opts, 'json');\n        this.assignOption(opts, 'preserveBuffers');\n        this.assignOption(opts, 'pingInterval');\n        this.assignOption(opts, 'maxPingOut');\n        this.assignOption(opts, 'useOldRequestStyle');\n    }\n\n    var client = this;\n\n    // Set user/pass as needed if in options.\n    client.user = options.user;\n    client.pass = options.pass;\n\n    // Set token as needed if in options.\n    client.token = options.token;\n\n    // Authentication - make sure authentication is valid.\n    if (client.user && client.token) {\n        throw (new NatsError(BAD_AUTHENTICATION_MSG, BAD_AUTHENTICATION));\n    }\n\n    // Encoding - make sure its valid.\n    if (Buffer.isEncoding(options.encoding)) {\n        client.encoding = options.encoding;\n    } else {\n        throw new NatsError(INVALID_ENCODING_MSG_PREFIX + options.encoding, INVALID_ENCODING);\n    }\n    // For cluster support\n    client.servers = [];\n\n    if (Array.isArray(options.servers)) {\n        options.servers.forEach(function(server) {\n            client.servers.push(new Server(url.parse(server)));\n        });\n      // Randomize if needed\n      if (options.noRandomize !== true) {\n        shuffle(client.servers);\n      }\n\n      // if they gave an URL we should add it if different\n      if(options.url !== undefined && client.servers.indexOf(options.url) === -1) {\n        //make url first element so it is attempted first\n        client.servers.unshift(new Server(url.parse(options.url)));\n      }\n    } else {\n        if (undefined === options.url) {\n            options.url = DEFAULT_URI;\n        }\n        client.servers.push(new Server(url.parse(options.url)));\n    }\n};\n\n/**\n * Create a new server.\n *\n * @api private\n */\nfunction Server(url) {\n    this.url = url;\n    this.didConnect = false;\n    this.reconnects = 0;\n}\n\n/**\n * @api private\n */\nServer.prototype.toString = function() {\n  return this.url.href;\n};\n\n/**\n * Properly select the next server.\n * We rotate the server list as we go,\n * we also pull auth from urls as needed, or\n * if they were set in options use that as override.\n *\n * @api private\n */\nClient.prototype.selectServer = function() {\n    var client = this;\n    var server = client.servers.shift();\n\n    // Place in client context.\n    client.currentServer = server;\n    client.url = server.url;\n    if ('auth' in server.url && !!server.url.auth) {\n        var auth = server.url.auth.split(':');\n        if (auth.length !== 1) {\n            if (client.options.user === undefined) {\n                client.user = auth[0];\n            }\n            if (client.options.pass === undefined) {\n                client.pass = auth[1];\n            }\n        } else {\n            if (client.options.token === undefined) {\n                client.token = auth[0];\n            }\n        }\n    }\n    client.servers.push(server);\n};\n\n/**\n * Check for TLS configuration mismatch.\n *\n * @api private\n */\nClient.prototype.checkTLSMismatch = function() {\n    if (this.info.tls_required === true &&\n        this.options.tls === false) {\n        this.emit('error', new NatsError(SECURE_CONN_REQ_MSG, SECURE_CONN_REQ));\n        this.closeStream();\n        return true;\n    }\n\n    if (!this.info.tls_required && this.options.tls !== false) {\n        this.emit('error', new NatsError(NON_SECURE_CONN_REQ_MSG, NON_SECURE_CONN_REQ));\n        this.closeStream();\n        return true;\n    }\n\n    if (this.info.tls_verify === true &&\n        this.options.tls.cert === undefined) {\n        this.emit('error', new NatsError(CLIENT_CERT_REQ_MSG, CLIENT_CERT_REQ));\n        this.closeStream();\n        return true;\n    }\n    return false;\n};\n\n/**\n * Callback for first flush/connect.\n *\n * @api private\n */\nClient.prototype.connectCB = function() {\n    var wasReconnecting = this.reconnecting;\n    var event = (wasReconnecting === true) ? 'reconnect' : 'connect';\n    this.reconnecting = false;\n    this.reconnects = 0;\n    this.wasConnected = true;\n    this.currentServer.didConnect = true;\n\n    this.emit(event, this);\n\n    this.flushPending();\n};\n\n\nClient.prototype.scheduleHeartbeat = function() {\n    this.pingTimer = setTimeout(function(client) {\n        client.emit('pingtimer');\n        if (client.closed) {\n            return;\n        }\n        // we could be waiting on the socket to connect\n        if (client.stream && !client.stream.connecting) {\n            client.emit('pingcount', client.pout);\n            client.pout++;\n            if (client.pout > client.options.maxPingOut) {\n                // processErr will scheduleReconnect\n                client.processErr(STALE_CONNECTION_ERR);\n                // don't reschedule, new connection initiated\n                return;\n            } else {\n                // send the ping\n                client.sendCommand(PING_REQUEST);\n                if (client.pongs) {\n                    // no callback\n                    client.pongs.push(undefined);\n                }\n\n            }\n        }\n        // reschedule\n        client.scheduleHeartbeat();\n    }, this.options.pingInterval, this);\n};\n\n/**\n * Properly setup a stream event handlers.\n *\n * @api private\n */\nClient.prototype.setupHandlers = function() {\n    var client = this;\n    var stream = client.stream;\n\n    if (undefined === stream) {\n        return;\n    }\n\n    stream.on('connect', function() {\n        if (client.pingTimer) {\n            clearTimeout(client.pingTimer);\n            delete client.pingTimer;\n        }\n        client.connected = true;\n        client.scheduleHeartbeat();\n    });\n\n    stream.on('close', function(hadError) {\n        client.closeStream();\n        client.emit('disconnect');\n        if (client.closed === true ||\n            client.options.reconnect === false ||\n            ((client.reconnects >= client.options.maxReconnectAttempts) && client.options.maxReconnectAttempts !== -1)) {\n            client.emit('close');\n        } else {\n            client.scheduleReconnect();\n        }\n    });\n\n    stream.on('error', function(exception) {\n        // If we were connected just return, close event will process\n        if (client.wasConnected === true && client.currentServer.didConnect === true) {\n            return;\n        }\n\n        // if the current server did not connect at all, and we in\n        // general have not connected to any server, remove it from\n        // this list. Unless overidden\n        if (client.wasConnected === false && client.currentServer.didConnect === false) {\n            // We can override this behavior with waitOnFirstConnect, which will\n            // treat it like a reconnect scenario.\n            if (client.options.waitOnFirstConnect) {\n                // Pretend to move us into a reconnect state.\n                client.currentServer.didConnect = true;\n            } else {\n                client.servers.splice(client.servers.length - 1, 1);\n            }\n        }\n\n        // Only bubble up error if we never had connected\n        // to the server and we only have one.\n        if (client.wasConnected === false && client.servers.length === 0) {\n            client.emit('error', new NatsError(CONN_ERR_MSG_PREFIX + exception, CONN_ERR, exception));\n        }\n        client.closeStream();\n    });\n\n    stream.on('data', function(data) {\n        // If inbound exists, concat them together. We try to avoid this for split\n        // messages, so this should only really happen for a split control line.\n        // Long term answer is hand rolled parser and not regexp.\n        if (client.inbound) {\n            client.inbound = Buffer.concat([client.inbound, data]);\n        } else {\n            client.inbound = data;\n        }\n\n        // Process the inbound queue.\n        client.processInbound();\n    });\n};\n\n/**\n * Send the connect command. This needs to happen after receiving the first\n * INFO message and after TLS is established if necessary.\n *\n * @api private\n */\nClient.prototype.sendConnect = function() {\n    // Queue the connect command.\n    var cs = {\n        'lang': 'node',\n        'version': VERSION,\n        'verbose': this.options.verbose,\n        'pedantic': this.options.pedantic,\n        'protocol': 1\n    };\n    if (this.user !== undefined) {\n        cs.user = this.user;\n        cs.pass = this.pass;\n    }\n    if (this.token !== undefined) {\n        cs.auth_token = this.token;\n    }\n    if (this.options.name !== undefined) {\n        cs.name = this.options.name;\n    }\n    // If we enqueued requests before we received INFO from the server, or we\n    // reconnected, there be other data pending, write this immediately instead\n    // of adding it to the queue.\n    this.stream.write(CONNECT + SPC + JSON.stringify(cs) + CR_LF);\n};\n\n/**\n * Properly setup a stream connection with proper events.\n *\n * @api private\n */\nClient.prototype.createConnection = function() {\n    // Commands may have been queued during reconnect. Discard everything except:\n    // 1) ping requests with a pong callback\n    // 2) publish requests\n    //\n    // Rationale: CONNECT and SUBs are written directly upon connecting, any PONG\n    // response is no longer relevant, and any UNSUB will be accounted for when we\n    // sync our SUBs. Without this, users of the client may miss state transitions\n    // via callbacks, would have to track the client's internal connection state,\n    // and may have to double buffer messages (which we are already doing) if they\n    // wanted to ensure their messages reach the server.\n    var pong = [];\n    var pend = [];\n    var pSize = 0;\n    var client = this;\n    if (client.pending !== null) {\n        var pongIndex = 0;\n        client.pending.forEach(function(cmd) {\n            var cmdLen = Buffer.isBuffer(cmd) ? cmd.length : Buffer.byteLength(cmd);\n            if (cmd === PING_REQUEST && client.pongs !== null && pongIndex < client.pongs.length) {\n                // filter out any useless ping requests (no pong callback, nop flush)\n                var p = client.pongs[pongIndex++];\n                if (p !== undefined) {\n                    pend.push(cmd);\n                    pSize += cmdLen;\n                    pong.push(p);\n                }\n            } else if (cmd.length > 3 && cmd[0] === 'P' && cmd[1] === 'U' && cmd[2] === 'B') {\n                pend.push(cmd);\n                pSize += cmdLen;\n            }\n        });\n    }\n    this.pongs = pong;\n    this.pending = pend;\n    this.pSize = pSize;\n\n    this.pstate = AWAITING_CONTROL;\n\n    // Clear info processing.\n    this.info = null;\n    this.infoReceived = false;\n\n    // Select a server to connect to.\n    this.selectServer();\n    // See #45 if we have a stream release the listeners\n    // otherwise in addition to the leak events will fire fire\n    if (this.stream) {\n        this.stream.removeAllListeners();\n        this.stream.destroy();\n    }\n    // Create the stream\n    this.stream = net.createConnection(this.url);\n    // this change makes it a bit faster on Linux, slightly worse on OS X\n    // this.stream.setNoDelay(true);\n    // Setup the proper handlers.\n    this.setupHandlers();\n};\n\n/**\n * Initialize client state.\n *\n * @api private\n */\nClient.prototype.initState = function() {\n    this.ssid = 1;\n    this.subs = {};\n    this.reconnects = 0;\n    this.connected = false;\n    this.wasConnected = false;\n    this.reconnecting = false;\n    this.server = null;\n    this.pending = [];\n    this.pout = 0;\n};\n\n/**\n * Close the connection to the server.\n *\n * @api public\n */\nClient.prototype.close = function() {\n    if(this.pingTimer) {\n        clearTimeout(this.pingTimer);\n        delete this.pingTimer;\n    }\n    this.closed = true;\n    this.removeAllListeners();\n    this.closeStream();\n    this.ssid = -1;\n    this.subs = null;\n    this.pstate = -1;\n    this.pongs = null;\n    this.pending = null;\n    this.pSize = 0;\n};\n\n/**\n * Close down the stream and clear state.\n *\n * @api private\n */\nClient.prototype.closeStream = function() {\n    if (this.stream !== null) {\n        this.stream.destroy();\n        this.stream = null;\n    }\n    if (this.connected === true || this.closed === true) {\n        this.pongs = null;\n        this.pout = 0;\n        this.pending = null;\n        this.pSize = 0;\n        this.connected = false;\n    }\n    this.inbound = null;\n};\n\n/**\n * Flush all pending data to the server.\n *\n * @api private\n */\nClient.prototype.flushPending = function() {\n    if (this.connected === false ||\n        this.pending === null ||\n        this.pending.length === 0 ||\n        this.infoReceived !== true) {\n        return;\n    }\n\n    var client = this;\n    var write = function(data) {\n        client.pending = [];\n        client.pSize = 0;\n        return client.stream.write(data);\n    };\n    if (!this.pBufs) {\n        // All strings, fastest for now.\n        return write(this.pending.join(EMPTY));\n    } else {\n        // We have some or all Buffers. Figure out if we can optimize.\n        var allBufs = true;\n        for (var i = 0; i < this.pending.length; i++) {\n            if (!Buffer.isBuffer(this.pending[i])) {\n                allBufs = false;\n                break;\n            }\n        }\n        // If all buffers, concat together and write once.\n        if (allBufs) {\n            return write(Buffer.concat(this.pending, this.pSize));\n        } else {\n            // We have a mix, so write each one individually.\n            var pending = this.pending;\n            this.pending = [];\n            this.pSize = 0;\n            var result = true;\n            for (i = 0; i < pending.length; i++) {\n                result = this.stream.write(pending[i]) && result;\n            }\n            return result;\n        }\n    }\n};\n\n/**\n * Strips all SUBS commands from pending during initial connection completed since\n * we send the subscriptions as a separate operation.\n *\n * @api private\n */\nClient.prototype.stripPendingSubs = function() {\n    var pending = this.pending;\n    this.pending = [];\n    this.pSize = 0;\n    for (var i = 0; i < pending.length; i++) {\n        if (!SUBRE.test(pending[i])) {\n            // Re-queue the command.\n            this.sendCommand(pending[i]);\n        }\n    }\n};\n\n/**\n * Send commands to the server or queue them up if connection pending.\n *\n * @api private\n */\nClient.prototype.sendCommand = function(cmd) {\n    // Buffer to cut down on system calls, increase throughput.\n    // When receive gets faster, should make this Buffer based..\n\n    if (this.closed || this.pending === null) {\n        return;\n    }\n\n    this.pending.push(cmd);\n    if (!Buffer.isBuffer(cmd)) {\n        this.pSize += Buffer.byteLength(cmd);\n    } else {\n        this.pSize += cmd.length;\n        this.pBufs = true;\n    }\n\n    if (this.connected === true) {\n        // First one let's setup flush..\n        if (this.pending.length === 1) {\n            var self = this;\n            setImmediate(function() {\n                self.flushPending();\n            });\n        } else if (this.pSize > FLUSH_THRESHOLD) {\n            // Flush in place when threshold reached..\n            this.flushPending();\n        }\n    }\n};\n\n/**\n * Sends existing subscriptions to new server after reconnect.\n *\n * @api private\n */\nClient.prototype.sendSubscriptions = function() {\n    var protos = \"\";\n    for (var sid in this.subs) {\n        if (this.subs.hasOwnProperty(sid)) {\n            var sub = this.subs[sid];\n            var proto;\n            if (sub.qgroup) {\n                proto = [SUB, sub.subject, sub.qgroup, sid + CR_LF];\n            } else {\n                proto = [SUB, sub.subject, sid + CR_LF];\n            }\n            protos += proto.join(SPC);\n        }\n    }\n    if (protos.length > 0) {\n        this.stream.write(protos);\n    }\n};\n\n/**\n * Process the inbound data queue.\n *\n * @api private\n */\nClient.prototype.processInbound = function() {\n    var client = this;\n\n    // Hold any regex matches.\n    var m;\n\n    // For optional yield\n    var start;\n\n    if (!client.stream) {\n        // if we are here, the stream was reaped and errors raised\n        // if we continue.\n        return;\n    }\n    // unpause if needed.\n    // FIXME(dlc) client.stream.isPaused() causes 0.10 to fail\n    client.stream.resume();\n\n    /* jshint -W083 */\n\n    if (client.options.yieldTime !== undefined) {\n        start = Date.now();\n    }\n\n    while (!client.closed && client.inbound && client.inbound.length > 0) {\n        switch (client.pstate) {\n\n            case AWAITING_CONTROL:\n                // Regex only works on strings, so convert once to be more efficient.\n                // Long term answer is a hand rolled parser, not regex.\n                var buf = client.inbound.toString('binary', 0, MAX_CONTROL_LINE_SIZE);\n                if ((m = MSG.exec(buf)) !== null) {\n                    client.payload = {\n                        subj: m[1],\n                        sid: parseInt(m[2], 10),\n                        reply: m[4],\n                        size: parseInt(m[5], 10)\n                    };\n                    client.payload.psize = client.payload.size + CR_LF_LEN;\n                    client.pstate = AWAITING_MSG_PAYLOAD;\n                } else if ((m = OK.exec(buf)) !== null) {\n                    // Ignore for now..\n                } else if ((m = ERR.exec(buf)) !== null) {\n                    client.processErr(m[1]);\n                    return;\n                } else if ((m = PONG.exec(buf)) !== null) {\n                    client.pout = 0;\n                    var cb = client.pongs && client.pongs.shift();\n                    if (cb) {\n                        cb();\n                    } // FIXME: Should we check for exceptions?\n                } else if ((m = PING.exec(buf)) !== null) {\n                    client.sendCommand(PONG_RESPONSE);\n                } else if ((m = INFO.exec(buf)) !== null) {\n                    client.info = JSON.parse(m[1]);\n                    // Check on TLS mismatch.\n                    if (client.checkTLSMismatch() === true) {\n                        return;\n                    }\n\n                    // Always try to read the connect_urls from info\n                    client.processServerUpdate();\n\n                    // Process first INFO\n                    if (client.infoReceived === false) {\n                        // Switch over to TLS as needed.\n                        if (client.options.tls !== false &&\n                            client.stream.encrypted !== true) {\n                            var tlsOpts = {\n                                socket: client.stream\n                            };\n                            if ('object' === typeof client.options.tls) {\n                                for (var key in client.options.tls) {\n                                    tlsOpts[key] = client.options.tls[key];\n                                }\n                            }\n                            // if we have a stream, this is from an old connection, reap it\n                            if (client.stream) {\n                                client.stream.removeAllListeners();\n                            }\n                            client.stream = tls.connect(tlsOpts, function() {\n                                client.flushPending();\n                            });\n                            client.setupHandlers();\n                        }\n\n                        // Send the connect message and subscriptions immediately\n                        client.sendConnect();\n                        client.sendSubscriptions();\n\n                        client.pongs.unshift(function() {\n                            client.connectCB();\n                        });\n                        client.stream.write(PING_REQUEST);\n\n                        // Mark as received\n                        client.infoReceived = true;\n                        client.stripPendingSubs();\n                        client.flushPending();\n                    }\n                } else {\n                    // FIXME, check line length for something weird.\n                    // Nothing here yet, return\n                    return;\n                }\n                break;\n\n            case AWAITING_MSG_PAYLOAD:\n\n                // If we do not have the complete message, hold onto the chunks\n                // and assemble when we have all we need. This optimizes for\n                // when we parse a large buffer down to a small number of bytes,\n                // then we receive a large chunk. This avoids a big copy with a\n                // simple concat above.\n                if (client.inbound.length < client.payload.psize) {\n                    if (undefined === client.payload.chunks) {\n                        client.payload.chunks = [];\n                    }\n                    client.payload.chunks.push(client.inbound);\n                    client.payload.psize -= client.inbound.length;\n                    client.inbound = null;\n                    return;\n                }\n\n                // If we are here we have the complete message.\n                // Check to see if we have existing chunks\n                if (client.payload.chunks) {\n\n                    client.payload.chunks.push(client.inbound.slice(0, client.payload.psize));\n                    // don't append trailing control characters\n                    var mbuf = Buffer.concat(client.payload.chunks, client.payload.size);\n\n                    if (client.options.preserveBuffers) {\n                        client.payload.msg = mbuf;\n                    } else {\n                        client.payload.msg = mbuf.toString(client.encoding);\n                    }\n\n                } else {\n\n                    if (client.options.preserveBuffers) {\n                        client.payload.msg = client.inbound.slice(0, client.payload.size);\n                    } else {\n                        client.payload.msg = client.inbound.toString(client.encoding, 0, client.payload.size);\n                    }\n\n                }\n\n                // Eat the size of the inbound that represents the message.\n                if (client.inbound.length === client.payload.psize) {\n                    client.inbound = null;\n                } else {\n                    client.inbound = client.inbound.slice(client.payload.psize);\n                }\n\n                // process the message\n                client.processMsg();\n\n                // Reset\n                client.pstate = AWAITING_CONTROL;\n                client.payload = null;\n\n                // Check to see if we have an option to yield for other events after yieldTime.\n                if (start !== undefined) {\n                    if ((Date.now() - start) > client.options.yieldTime) {\n                        client.stream.pause();\n                        setImmediate(client.processInbound.bind(this));\n                        return;\n                    }\n                }\n                break;\n        }\n\n        // This is applicable for a regex match to eat the bytes we used from a control line.\n        if (m && !this.closed) {\n            // Chop inbound\n            var psize = m[0].length;\n            if (psize >= client.inbound.length) {\n                client.inbound = null;\n            } else {\n                client.inbound = client.inbound.slice(psize);\n            }\n        }\n        m = null;\n    }\n};\n\n/**\n * Process server updates in info object\n * @api internal\n */\nClient.prototype.processServerUpdate = function() {\n  var client = this;\n  if (client.info.connect_urls && client.info.connect_urls.length > 0) {\n    // parse the infos\n    var tmp = {};\n    client.info.connect_urls.forEach(function(server) {\n      var u = 'nats://' + server;\n      var s = new Server(url.parse(u));\n      // implicit servers are ones added via the info connect_urls\n      s.implicit = true;\n      tmp[s.url.href] = s;\n    });\n\n    // remove implicit servers that are no longer reported\n    var toDelete = [];\n    client.servers.forEach(function(s, index) {\n      var u = s.url.href;\n      if(s.implicit && client.currentServer.url.href !== u && tmp[u] === undefined) {\n        // server was removed\n        toDelete.push(index);\n      }\n      // remove this entry from reported\n      delete tmp[u];\n    });\n\n    // perform the deletion\n    toDelete.reverse();\n    toDelete.forEach(function(index) {\n      client.servers.splice(index, 1);\n    });\n\n    // remaining servers are new\n    var newURLs = [];\n    for(var k in tmp) {\n      if(tmp.hasOwnProperty(k)) {\n        client.servers.push(tmp[k]);\n        newURLs.push(k);\n      }\n    }\n\n    if(newURLs.length) {\n      // new reported servers useful for tests\n      client.emit('serversDiscovered', newURLs);\n    }\n  }\n};\n\n/**\n * Process a delivered message and deliver to appropriate subscriber.\n *\n * @api private\n */\nClient.prototype.processMsg = function() {\n    var sub = this.subs[this.payload.sid];\n    if (sub !== undefined) {\n        sub.received += 1;\n        // Check for a timeout, and cancel if received >= expected\n        if (sub.timeout) {\n            if (sub.received >= sub.expected) {\n                clearTimeout(sub.timeout);\n                sub.timeout = null;\n            }\n        }\n        // Check for auto-unsubscribe\n        if (sub.max !== undefined) {\n            if (sub.received === sub.max) {\n                delete this.subs[this.payload.sid];\n                this.emit('unsubscribe', this.payload.sid, sub.subject);\n            } else if (sub.received > sub.max) {\n                this.unsubscribe(this.payload.sid);\n                sub.callback = null;\n            }\n        }\n\n        if (sub.callback) {\n            var msg = this.payload.msg;\n            if (this.options.json) {\n                try {\n                    if (this.options.preserveBuffers) {\n                        msg = JSON.parse(this.payload.msg.toString());\n                    } else {\n                        msg = JSON.parse(this.payload.msg.toString(this.options.encoding));\n                    }\n                } catch (e) {\n                    msg = e;\n                }\n            }\n            try {\n                sub.callback(msg, this.payload.reply, this.payload.subj, this.payload.sid);\n            } catch(error) {\n                this.emit('error', error);\n            }\n        }\n    }\n};\n\n/**\n * ProcessErr processes any error messages from the server\n *\n * @api private\n */\nClient.prototype.processErr = function(s) {\n    // current NATS clients, will raise an error and close on any errors\n    // except stale connection and permission errors\n    var m = s ? s.toLowerCase() : '';\n    if (m.indexOf(STALE_CONNECTION_ERR) !== -1) {\n        // closeStream() triggers a reconnect if allowed\n        this.closeStream();\n    } else if (m.indexOf(PERMISSIONS_ERR) !== -1) {\n        this.emit('permission_error', new NatsError(s, NATS_PROTOCOL_ERR));\n    } else {\n        this.emit('error', new NatsError(s, NATS_PROTOCOL_ERR));\n        this.closeStream();\n    }\n};\n\n/**\n * Push a new cluster server.\n *\n * @param {String} uri\n * @api public\n */\nClient.prototype.addServer = function(uri) {\n    this.servers.push(new Server(url.parse(uri)));\n\n    if (this.options.noRandomize !== true) {\n        shuffle(this.servers);\n    }\n};\n\n/**\n * Flush outbound queue to server and call optional callback when server has processed\n * all data.\n *\n * @param {Function} [opt_callback]\n * @api public\n */\nClient.prototype.flush = function(opt_callback) {\n    if (this.closed) {\n        if (typeof opt_callback === 'function') {\n            opt_callback(new NatsError(CONN_CLOSED_MSG, CONN_CLOSED));\n            return;\n        } else {\n            throw (new NatsError(CONN_CLOSED_MSG, CONN_CLOSED));\n        }\n    }\n    if (this.pongs) {\n        this.pongs.push(opt_callback);\n        this.sendCommand(PING_REQUEST);\n        this.flushPending();\n    }\n};\n\n/**\n * Publish a message to the given subject, with optional reply and callback.\n *\n * @param {String} subject\n * @param {String} [msg]\n * @param {String} [opt_reply]\n * @param {Function} [opt_callback]\n * @api public\n */\nClient.prototype.publish = function(subject, msg, opt_reply, opt_callback) {\n    // They only supplied a callback function.\n    if (typeof subject === 'function') {\n        opt_callback = subject;\n        subject = undefined;\n    }\n\n    if (!this.options.json) {\n        msg = msg || EMPTY;\n    } else {\n        // undefined is not a valid JSON-serializable value, but null is\n        msg = msg === undefined ? null : msg;\n    }\n\n    if (!subject) {\n        if (opt_callback) {\n            opt_callback(new NatsError(BAD_SUBJECT_MSG, BAD_SUBJECT));\n        } else {\n            throw (new NatsError(BAD_SUBJECT_MSG, BAD_SUBJECT));\n        }\n    }\n    if (typeof msg === 'function') {\n        if (opt_callback || opt_reply) {\n            opt_callback(new NatsError(BAD_MSG_MSG, BAD_MSG));\n            return;\n        }\n        opt_callback = msg;\n        msg = EMPTY;\n        opt_reply = undefined;\n    }\n    if (typeof opt_reply === 'function') {\n        if (opt_callback) {\n            opt_callback(new NatsError(BAD_REPLY_MSG, BAD_REPLY));\n            return;\n        }\n        opt_callback = opt_reply;\n        opt_reply = undefined;\n    }\n\n    // Hold PUB SUB [REPLY]\n    var psub;\n    if (opt_reply === undefined) {\n        psub = 'PUB ' + subject + SPC;\n    } else {\n        psub = 'PUB ' + subject + SPC + opt_reply + SPC;\n    }\n\n    // Need to treat sending buffers different.\n    if (!Buffer.isBuffer(msg)) {\n        var str = msg;\n        if (this.options.json) {\n            try {\n                str = JSON.stringify(msg);\n            } catch (e) {\n                throw (new NatsError(BAD_JSON_MSG, BAD_JSON));\n            }\n        }\n        this.sendCommand(psub + Buffer.byteLength(str) + CR_LF + str + CR_LF);\n    } else {\n        var b = Buffer.allocUnsafe(psub.length + msg.length + (2 * CR_LF_LEN) + msg.length.toString().length);\n        var len = b.write(psub + msg.length + CR_LF);\n        msg.copy(b, len);\n        b.write(CR_LF, len + msg.length);\n        this.sendCommand(b);\n    }\n\n    if (opt_callback !== undefined) {\n        this.flush(opt_callback);\n    } else if (this.closed) {\n        throw (new NatsError(CONN_CLOSED_MSG, CONN_CLOSED));\n    }\n};\n\n/**\n * Subscribe to a given subject, with optional options and callback. opts can be\n * ommitted, even with a callback. The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {Object} [opts]\n * @param {Function} callback\n * @return {Number}\n * @api public\n */\nClient.prototype.subscribe = function(subject, opts, callback) {\n    if (this.closed) {\n        throw (new NatsError(CONN_CLOSED_MSG, CONN_CLOSED));\n    }\n    var qgroup, max;\n    if (typeof opts === 'function') {\n        callback = opts;\n        opts = undefined;\n    } else if (opts && typeof opts === 'object') {\n        // FIXME, check exists, error otherwise..\n        qgroup = opts.queue;\n        max = opts.max;\n    }\n    this.ssid += 1;\n    this.subs[this.ssid] = {\n        'subject': subject,\n        'callback': callback,\n        'received': 0\n    };\n\n    var proto;\n    if (typeof qgroup === 'string') {\n        this.subs[this.ssid].qgroup = qgroup;\n        proto = [SUB, subject, qgroup, this.ssid + CR_LF];\n    } else {\n        proto = [SUB, subject, this.ssid + CR_LF];\n    }\n\n    this.sendCommand(proto.join(SPC));\n    this.emit('subscribe', this.ssid, subject, opts);\n\n    if (max) {\n        this.unsubscribe(this.ssid, max);\n    }\n    return this.ssid;\n};\n\n/**\n * Unsubscribe to a given Subscriber Id, with optional max parameter.\n * Unsubscribing to a subscription that already yielded the specified number of messages\n * will clear any pending timeout callbacks.\n *\n * @param {Number} sid\n * @param {Number} [opt_max]\n * @api public\n */\nClient.prototype.unsubscribe = function(sid, opt_max) {\n    if (!sid || this.closed) {\n        return;\n    }\n\n    // in the case of new muxRequest, it is possible they want perform\n    // an unsubscribe with the returned 'sid'. Intercept that and clear\n    // the request configuration. Mux requests are always negative numbers\n    if(sid < 0) {\n        this.cancelMuxRequest(sid);\n        return;\n    }\n\n    var proto;\n    if (opt_max) {\n        proto = [UNSUB, sid, opt_max + CR_LF];\n    } else {\n        proto = [UNSUB, sid + CR_LF];\n    }\n    this.sendCommand(proto.join(SPC));\n\n    var sub = this.subs[sid];\n    if (sub === undefined) {\n        return;\n    }\n    sub.max = opt_max;\n    if (sub.max === undefined || (sub.received >= sub.max)) {\n        // remove any timeouts that may be pending\n        if (sub.timeout) {\n            clearTimeout(sub.timeout);\n            sub.timeout = null;\n        }\n        delete this.subs[sid];\n        this.emit('unsubscribe', sid, sub.subject);\n    }\n};\n\n/**\n * Set a timeout on a subscription. The subscription is cancelled if the\n * expected number of messages is reached or the timeout is reached.\n * If this function is called with an SID from a multiplexed\n * request call, the original timeout handler associated with the multiplexed\n * request is replaced with the one provided to this function.\n *\n * @param {Number} sid\n * @param {Number} timeout\n * @param {Number} expected\n * @param {Function} callback\n * @api public\n */\nClient.prototype.timeout = function(sid, timeout, expected, callback) {\n    if (!sid) {\n        return;\n    }\n    var sub = null;\n    // check the sid is not a mux sid - which is always negative\n    if(sid < 0) {\n        var conf = this.getMuxRequestConfig(sid);\n        if(conf && conf.timeout) {\n            // clear auto-set timeout\n            clearTimeout(conf.timeout);\n        }\n        sub = conf;\n    } else {\n        sub = this.subs[sid];\n    }\n\n    if(sub) {\n        sub.expected = expected;\n        var that = this;\n        sub.timeout = setTimeout(function () {\n            callback(sid);\n            // if callback fails unsubscribe will leak\n            that.unsubscribe(sid);\n        }, timeout);\n    }\n};\n\n\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. You can optionally indicate how many\n * messages you only want to receive using opt_options = {max:N}. Otherwise you\n * will need to unsubscribe to stop the message stream.\n *\n * You can also optionally specify the number of milliseconds to wait for the messages\n * to receive using opt_options = {timeout: N}. When the number of messages specified\n * is received before a timeout, the subscription auto-cancels. If the number of messages\n * is not specified, it is the responsibility of the client to unsubscribe to prevent\n * a timeout.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String} [opt_msg]\n * @param {Object} [opt_options]\n * @param {Function} [callback]\n * @return {Number}\n * @api public\n */\nClient.prototype.request = function(subject, opt_msg, opt_options, callback) {\n    if(this.options.useOldRequestStyle) {\n        return this.oldRequest(subject, opt_msg, opt_options, callback);\n    }\n    if (typeof opt_msg === 'function') {\n        callback = opt_msg;\n        opt_msg = EMPTY;\n        opt_options = null;\n    }\n    if (typeof opt_options === 'function') {\n        callback = opt_options;\n        opt_options = null;\n    }\n\n    opt_options = opt_options || {};\n    var conf = this.initMuxRequestDetails(callback, opt_options.max);\n    this.publish(subject, opt_msg, conf.inbox);\n\n    if(opt_options.timeout) {\n        var client = this;\n        conf.timeout = setTimeout(function() {\n            if(conf.callback) {\n                conf.callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + conf.id, REQ_TIMEOUT));\n            }\n            client.cancelMuxRequest(conf.token);\n        }, opt_options.timeout);\n    }\n\n    return conf.id;\n};\n\n\n/**\n * @deprecated\n * @api private\n */\nClient.prototype.oldRequest = function(subject, opt_msg, opt_options, callback) {\n    if (typeof opt_msg === 'function') {\n        callback = opt_msg;\n        opt_msg = EMPTY;\n        opt_options = null;\n    }\n    if (typeof opt_options === 'function') {\n        callback = opt_options;\n        opt_options = null;\n    }\n    var inbox = createInbox();\n    var s = this.subscribe(inbox, opt_options, function(msg, reply) {\n        callback(msg, reply);\n    });\n    this.publish(subject, opt_msg, inbox);\n    return s;\n};\n\n/**\n * Publish a message with an implicit inbox listener as the reply. Message is optional.\n * This should be treated as a subscription. The subscription is auto-cancelled after the\n * first reply is received or the timeout in millisecond is reached.\n *\n * If a timeout is reached, the callback is invoked with a NatsError with it's code set to\n * `REQ_TIMEOUT` on the first argument of the callback function, and the subscription is\n * cancelled.\n *\n * The Subscriber Id is returned.\n *\n * @param {String} subject\n * @param {String} [opt_msg]\n * @param {Object} [opt_options]\n * @param {Number} timeout\n * @param {Function} callback - can be called with message or NatsError if the request timed out.\n * @return {Number}\n * @api public\n */\nClient.prototype.requestOne = function(subject, opt_msg, opt_options, timeout, callback) {\n    if(this.options.useOldRequestStyle) {\n        return this.oldRequestOne(subject, opt_msg, opt_options, timeout, callback);\n    }\n\n    if (typeof opt_msg === 'number') {\n        callback = opt_options;\n        timeout = opt_msg;\n        opt_options = null;\n        opt_msg = EMPTY;\n    }\n\n    if (typeof opt_options === 'number') {\n        callback = timeout;\n        timeout = opt_options;\n        opt_options = null;\n    }\n\n    opt_options = opt_options || {};\n    opt_options.max = 1;\n    opt_options.timeout = timeout;\n\n    return this.request(subject, opt_msg, opt_options, callback);\n};\n\n/**\n * Strips the prefix of the request reply to derive the token.\n * This is internal and only used by the new requestOne.\n *\n * @api private\n */\nClient.prototype.extractToken = function(subject) {\n    return subject.substr(this.respmux.inboxPrefixLen);\n};\n\n/**\n * Creates a subscription for the global inbox in the new requestOne.\n * Request tokens, timer, and callbacks are tracked here.\n *\n * @api private\n */\nClient.prototype.createResponseMux = function() {\n    if(!this.respmux) {\n        var client = this;\n        var inbox = createInbox();\n        var ginbox = inbox + \".*\";\n        var sid = this.subscribe(ginbox, function(msg, reply, subject) {\n            var token = client.extractToken(subject);\n            var conf = client.getMuxRequestConfig(token);\n            if(conf) {\n                if(conf.hasOwnProperty('expected')) {\n                    conf.received++;\n                    if (conf.received >= conf.expected) {\n                        client.cancelMuxRequest(token);\n                    }\n                }\n                if(conf.callback) {\n                    conf.callback(msg, reply);\n                }\n            }\n        });\n        this.respmux = {};\n        this.respmux.inbox = inbox;\n        this.respmux.inboxPrefixLen = inbox.length + 1;\n        this.respmux.subscriptionID = sid;\n        this.respmux.requestMap = {};\n        this.respmux.nextID = -1;\n    }\n    return this.respmux.inbox;\n};\n\n/**\n * Stores the request callback and other details\n *\n * @api private\n */\nClient.prototype.initMuxRequestDetails = function(callback, expected) {\n    var ginbox = this.createResponseMux();\n    var token = nuid.next();\n    var inbox = ginbox + '.' + token;\n\n    var conf = {token: token, callback: callback, inbox: inbox, id: this.respmux.nextID--, received: 0};\n    if(expected > 0) {\n        conf.expected = expected;\n    }\n\n    this.respmux.requestMap[token] = conf;\n    return conf;\n};\n\n/**\n * Returns the mux request configuration\n * @param token\n * @returns Object\n */\nClient.prototype.getMuxRequestConfig = function(token) {\n    // if the token is a number, we have a fake sid, find the request\n    if (typeof token === 'number') {\n        var entry = null;\n        for (var p in this.respmux.requestMap) {\n            if (this.respmux.requestMap.hasOwnProperty(p)) {\n                var v = this.respmux.requestMap[p];\n                if (v.id === token) {\n                    entry = v;\n                    break;\n                }\n            }\n        }\n        if (entry) {\n            token = entry.token;\n        }\n    }\n    return this.respmux.requestMap[token];\n};\n\n/**\n * Cancels the mux request\n *\n * @api private\n */\nClient.prototype.cancelMuxRequest = function(token) {\n    var conf = this.getMuxRequestConfig(token);\n    if (conf) {\n        if(conf.timeout) {\n            clearTimeout(conf.timeout);\n        }\n        // the token could be sid, so use the one in the conf\n        delete this.respmux.requestMap[conf.token];\n    }\n    return conf;\n};\n\n/**\n * @deprecated\n * @api private\n */\nClient.prototype.oldRequestOne = function(subject, opt_msg, opt_options, timeout, callback) {\n    if (typeof opt_msg === 'number') {\n        callback = opt_options;\n        timeout = opt_msg;\n        opt_options = null;\n        opt_msg = EMPTY;\n    }\n\n    if (typeof opt_options === 'number') {\n        callback = timeout;\n        timeout = opt_options;\n        opt_options = null;\n    }\n\n    opt_options = opt_options || {};\n    opt_options.max = 1;\n\n    var sid = this.request(subject, opt_msg, opt_options, callback);\n    this.timeout(sid, timeout, 1, function() {\n        callback(new NatsError(REQ_TIMEOUT_MSG_PREFIX + sid, REQ_TIMEOUT));\n    });\n    return sid;\n};\n\n/**\n * Report number of outstanding subscriptions on this connection.\n *\n * @return {Number}\n * @api public\n */\nClient.prototype.numSubscriptions = function() {\n    return Object.keys(this.subs).length;\n};\n\n/**\n * Reconnect to the server.\n *\n * @api private\n */\nClient.prototype.reconnect = function() {\n    if (this.closed) {\n        return;\n    }\n    this.reconnects += 1;\n    this.createConnection();\n    if (this.currentServer.didConnect === true) {\n        this.emit('reconnecting');\n    }\n};\n\n/**\n * Setup a timer event to attempt reconnect.\n *\n * @api private\n */\nClient.prototype.scheduleReconnect = function() {\n    var client = this;\n    // Just return if no more servers\n    if (client.servers.length === 0) {\n        return;\n    }\n    // Don't set reconnecting state if we are just trying\n    // for the first time.\n    if (client.wasConnected === true) {\n        client.reconnecting = true;\n    }\n    // Only stall if we have connected before.\n    var wait = 0;\n    if (client.servers[0].didConnect === true) {\n        wait = this.options.reconnectTimeWait;\n    }\n    setTimeout(function() {\n        client.reconnect();\n    }, wait);\n};\n\n\n//# sourceURL=webpack://NATS/./lib/nats.js?");

/***/ }),

/***/ "./lib/net.js":
/*!********************!*\
  !*** ./lib/net.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var env = __webpack_require__(/*! ./env */ \"./lib/env.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nvar WebSocket = env.isNode() ? __webpack_require__(/*! websocket */ \"./node_modules/websocket/index.js\").w3cwebsocket : window.WebSocket;\n\nfunction WebSocketProxy (url) {\n  var self = this;\n  EventEmitter.call(this);\n\n  if (env.isNode()) {\n    this.sock = new WebSocket(url, '', '*');\n\n    this.sock.onopen = function() {\n      self.emit('connect');\n    };\n    this.sock.onmessage = function(e) {\n      self.emit('data', new Buffer(e.data));\n    };\n    this.sock.onerror = function(e) {\n      self.emit('error', e);\n    };\n    this.sock.onclose = function() {\n      self.emit('close');\n    };\n  }\n  else {\n    this.sock = new WebSocket(url);\n    this.sock.addEventListener('open', function() {\n      self.emit('connect');\n    });\n    this.sock.addEventListener('message', function(e) {\n      self.emit('data', new Buffer(e.data));\n    });\n    this.sock.addEventListener('error', function(e) {\n      self.emit('error', e);\n    });\n    this.sock.addEventListener('close', function() {\n      self.emit('close');\n    });\n  }\n\n}\n\nutil.inherits(WebSocketProxy, EventEmitter);\n\nWebSocketProxy.prototype.end = function() {\n  this.destroy();\n};\n\nWebSocketProxy.prototype.destroy = function() {\n  if (this.sock.readyState === WebSocket.CONNECTING || this.sock.readyState === WebSocket.OPEN) {\n    this.sock.close();\n  }\n};\n\nWebSocketProxy.prototype.write = function(data) {\n  if (this.sock.readyState === WebSocket.OPEN) {\n    this.sock.send(data);\n  }\n};\n\nWebSocketProxy.prototype.pause = function() {\n  console.warn('WebSocketProxy stream pause/resume is not supported yet.');\n};\n\nWebSocketProxy.prototype.resume = function() { };\n\n// IMPORTANT: nats.js needs to be patched:\n// replace: this.stream = net.createConnection(this.url.port, this.url.hostname);\n// with: this.stream = net.createConnection(this.url);\n\n// IMPORTANT: if NOT using NodeJS 10.x\n// comment out the following line: this.stream.setNoDelay(true);\n\nexports.createConnection = function(url) {\n  // The url is rebuilt to avoid including the auth credentials.\n  return new WebSocketProxy(url.format({\n    protocol: url.protocol,\n    slashes: url.slashes,\n    host: url.host,\n    hostname: url.hostname,\n    port: url.port,\n    pathname: url.pathname,\n    search: url.search,\n    path: url.path,\n    query: url.query,\n    hash: url.hash\n  }));\n};\n\n\n//# sourceURL=webpack://NATS/./lib/net.js?");

/***/ }),

/***/ "./lib/nuid.js":
/*!*********************!*\
  !*** ./lib/nuid.js ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/*\n * Copyright 2016-2018 The NATS Authors\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* jslint node: true */\n\n\n/**\n * Module Dependencies\n */\n\nvar crypto = __webpack_require__(/*! ./crypto */ \"./lib/crypto.js\");\n\n/**\n * Constants\n */\nvar VERSION  = '1.0.0',\n    digits   = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',\n    base     = 36,\n    preLen   = 12,\n    seqLen   = 10,\n    maxSeq   = 3656158440062976,  // base^seqLen == 36^10\n    minInc   = 33,\n    maxInc   = 333,\n    totalLen = preLen + seqLen;\n\nexports.version = VERSION;\n\n/**\n * Create and initialize a nuid.\n *\n * @api private\n */\n\nfunction Nuid () {\n  this.buf = Buffer.alloc(totalLen);\n  this.init();\n}\n\n/**\n * Initializes a nuid with a crypto random prefix,\n * and pseudo-random sequence and increment.\n *\n * @api private\n */\n\nNuid.prototype.init = function() {\n  this.setPre();\n  this.initSeqAndInc();\n  this.fillSeq();\n};\n\n/**\n * Initializes the pseudo randmon sequence number and the increment range.\n *\n * @api private\n */\n\nNuid.prototype.initSeqAndInc = function() {\n  this.seq = Math.floor(Math.random() * maxSeq);\n  this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);\n};\n\n/**\n * Sets the prefix from crypto random bytes. Converts to base36.\n *\n * @api private\n */\n\nNuid.prototype.setPre = function() {\n  var cbuf = crypto.randomBytes(preLen);\n  for (var i = 0; i < preLen; i++) {\n    var di = cbuf[i] % base;\n    this.buf[i] = digits.charCodeAt(di);\n  }\n};\n\n/**\n * Fills the sequence part of the nuid as base36 from this.seq.\n *\n * @api private\n */\n\nNuid.prototype.fillSeq = function() {\n  var n = this.seq;\n  for (var i = totalLen - 1; i >= preLen; i--) {\n    this.buf[i] = digits.charCodeAt(n % base);\n    n = Math.floor(n / base);\n  }\n};\n\n/**\n * Returns the next nuid.\n *\n * @api private\n */\n\nNuid.prototype.next = function() {\n  this.seq += this.inc;\n  if (this.seq > maxSeq) {\n    this.setPre();\n    this.initSeqAndInc();\n  }\n  this.fillSeq();\n  return (this.buf.toString('ascii'));\n};\n\n/* Global Nuid */\nvar g = new Nuid();\n\n/**\n * Resets the prefix of the global nuid, as well as the\n * pseudo random sequence number and increment amounts.\n *\n * @api public\n */\n\nexports.reset = function() {\n  g.init();\n};\n\n/**\n * Returns the next nuid from the global.\n *\n * @api public\n */\n\nexports.next = function() {\n  return g.next();\n};\n\n/**\n * This here to facilitate testing\n * @api private\n */\nexports._global = g;\n\n\n//# sourceURL=webpack://NATS/./lib/nuid.js?");

/***/ }),

/***/ "./lib/tls.js":
/*!********************!*\
  !*** ./lib/tls.js ***!
  \********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("exports.connect = function(opts, cb) {\n  throw 'TLS is not supported in the browser. Use WSS instead.';\n};\n\n\n//# sourceURL=webpack://NATS/./lib/tls.js?");

/***/ }),

/***/ "./node_modules/debug/src/browser.js":
/*!*******************************************!*\
  !*** ./node_modules/debug/src/browser.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  'lightseagreen',\n  'forestgreen',\n  'goldenrod',\n  'dodgerblue',\n  'darkorchid',\n  'crimson'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/debug/src/browser.js?");

/***/ }),

/***/ "./node_modules/debug/src/debug.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = __webpack_require__(/*! ms */ \"./node_modules/ms/index.js\");\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Previous log timestamp.\n */\n\nvar prevTime;\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  return debug;\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (var i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/debug/src/debug.js?");

/***/ }),

/***/ "./node_modules/debug/src/index.js":
/*!*****************************************!*\
  !*** ./node_modules/debug/src/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Detect Electron renderer process, which is node, but we should\n * treat as a browser.\n */\n\nif (typeof process !== 'undefined' && process.type === 'renderer') {\n  module.exports = __webpack_require__(/*! ./browser.js */ \"./node_modules/debug/src/browser.js\");\n} else {\n  module.exports = __webpack_require__(/*! ./node.js */ \"./node_modules/debug/src/node.js\");\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/debug/src/index.js?");

/***/ }),

/***/ "./node_modules/debug/src/node.js":
/*!****************************************!*\
  !*** ./node_modules/debug/src/node.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Module dependencies.\n */\n\nvar tty = __webpack_require__(/*! tty */ \"tty\");\nvar util = __webpack_require__(/*! util */ \"util\");\n\n/**\n * This is the Node.js implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = __webpack_require__(/*! ./debug */ \"./node_modules/debug/src/debug.js\");\nexports.init = init;\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\n\n/**\n * Colors.\n */\n\nexports.colors = [6, 2, 3, 4, 5, 1];\n\n/**\n * Build up the default `inspectOpts` object from the environment variables.\n *\n *   $ DEBUG_COLORS=no DEBUG_DEPTH=10 DEBUG_SHOW_HIDDEN=enabled node script.js\n */\n\nexports.inspectOpts = Object.keys(process.env).filter(function (key) {\n  return /^debug_/i.test(key);\n}).reduce(function (obj, key) {\n  // camel-case\n  var prop = key\n    .substring(6)\n    .toLowerCase()\n    .replace(/_([a-z])/g, function (_, k) { return k.toUpperCase() });\n\n  // coerce string value into JS value\n  var val = process.env[key];\n  if (/^(yes|on|true|enabled)$/i.test(val)) val = true;\n  else if (/^(no|off|false|disabled)$/i.test(val)) val = false;\n  else if (val === 'null') val = null;\n  else val = Number(val);\n\n  obj[prop] = val;\n  return obj;\n}, {});\n\n/**\n * The file descriptor to write the `debug()` calls to.\n * Set the `DEBUG_FD` env variable to override with another value. i.e.:\n *\n *   $ DEBUG_FD=3 node script.js 3>debug.log\n */\n\nvar fd = parseInt(process.env.DEBUG_FD, 10) || 2;\n\nif (1 !== fd && 2 !== fd) {\n  util.deprecate(function(){}, 'except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)')()\n}\n\nvar stream = 1 === fd ? process.stdout :\n             2 === fd ? process.stderr :\n             createWritableStdioStream(fd);\n\n/**\n * Is stdout a TTY? Colored output is enabled when `true`.\n */\n\nfunction useColors() {\n  return 'colors' in exports.inspectOpts\n    ? Boolean(exports.inspectOpts.colors)\n    : tty.isatty(fd);\n}\n\n/**\n * Map %o to `util.inspect()`, all on a single line.\n */\n\nexports.formatters.o = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts)\n    .split('\\n').map(function(str) {\n      return str.trim()\n    }).join(' ');\n};\n\n/**\n * Map %o to `util.inspect()`, allowing multiple lines if needed.\n */\n\nexports.formatters.O = function(v) {\n  this.inspectOpts.colors = this.useColors;\n  return util.inspect(v, this.inspectOpts);\n};\n\n/**\n * Adds ANSI color escape codes if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var name = this.namespace;\n  var useColors = this.useColors;\n\n  if (useColors) {\n    var c = this.color;\n    var prefix = '  \\u001b[3' + c + ';1m' + name + ' ' + '\\u001b[0m';\n\n    args[0] = prefix + args[0].split('\\n').join('\\n' + prefix);\n    args.push('\\u001b[3' + c + 'm+' + exports.humanize(this.diff) + '\\u001b[0m');\n  } else {\n    args[0] = new Date().toUTCString()\n      + ' ' + name + ' ' + args[0];\n  }\n}\n\n/**\n * Invokes `util.format()` with the specified arguments and writes to `stream`.\n */\n\nfunction log() {\n  return stream.write(util.format.apply(util, arguments) + '\\n');\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  if (null == namespaces) {\n    // If you set a process.env field to null or undefined, it gets cast to the\n    // string 'null' or 'undefined'. Just delete instead.\n    delete process.env.DEBUG;\n  } else {\n    process.env.DEBUG = namespaces;\n  }\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  return process.env.DEBUG;\n}\n\n/**\n * Copied from `node/src/node.js`.\n *\n * XXX: It's lame that node doesn't expose this API out-of-the-box. It also\n * relies on the undocumented `tty_wrap.guessHandleType()` which is also lame.\n */\n\nfunction createWritableStdioStream (fd) {\n  var stream;\n  var tty_wrap = process.binding('tty_wrap');\n\n  // Note stream._type is used for test-module-load-list.js\n\n  switch (tty_wrap.guessHandleType(fd)) {\n    case 'TTY':\n      stream = new tty.WriteStream(fd);\n      stream._type = 'tty';\n\n      // Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    case 'FILE':\n      var fs = __webpack_require__(/*! fs */ \"fs\");\n      stream = new fs.SyncWriteStream(fd, { autoClose: false });\n      stream._type = 'fs';\n      break;\n\n    case 'PIPE':\n    case 'TCP':\n      var net = __webpack_require__(/*! net */ \"net\");\n      stream = new net.Socket({\n        fd: fd,\n        readable: false,\n        writable: true\n      });\n\n      // FIXME Should probably have an option in net.Socket to create a\n      // stream from an existing fd which is writable only. But for now\n      // we'll just add this hack and set the `readable` member to false.\n      // Test: ./node test/fixtures/echo.js < /etc/passwd\n      stream.readable = false;\n      stream.read = null;\n      stream._type = 'pipe';\n\n      // FIXME Hack to have stream not keep the event loop alive.\n      // See https://github.com/joyent/node/issues/1726\n      if (stream._handle && stream._handle.unref) {\n        stream._handle.unref();\n      }\n      break;\n\n    default:\n      // Probably an error on in uv_guess_handle()\n      throw new Error('Implement me. Unknown stream file type!');\n  }\n\n  // For supporting legacy API we put the FD here.\n  stream.fd = fd;\n\n  stream._isStdio = true;\n\n  return stream;\n}\n\n/**\n * Init logic for `debug` instances.\n *\n * Create a new `inspectOpts` object in case `useColors` is set\n * differently for a particular `debug` instance.\n */\n\nfunction init (debug) {\n  debug.inspectOpts = {};\n\n  var keys = Object.keys(exports.inspectOpts);\n  for (var i = 0; i < keys.length; i++) {\n    debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];\n  }\n}\n\n/**\n * Enable namespaces listed in `process.env.DEBUG` initially.\n */\n\nexports.enable(load());\n\n\n//# sourceURL=webpack://NATS/./node_modules/debug/src/node.js?");

/***/ }),

/***/ "./node_modules/is-typedarray/index.js":
/*!*********************************************!*\
  !*** ./node_modules/is-typedarray/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports      = isTypedArray\nisTypedArray.strict = isStrictTypedArray\nisTypedArray.loose  = isLooseTypedArray\n\nvar toString = Object.prototype.toString\nvar names = {\n    '[object Int8Array]': true\n  , '[object Int16Array]': true\n  , '[object Int32Array]': true\n  , '[object Uint8Array]': true\n  , '[object Uint8ClampedArray]': true\n  , '[object Uint16Array]': true\n  , '[object Uint32Array]': true\n  , '[object Float32Array]': true\n  , '[object Float64Array]': true\n}\n\nfunction isTypedArray(arr) {\n  return (\n       isStrictTypedArray(arr)\n    || isLooseTypedArray(arr)\n  )\n}\n\nfunction isStrictTypedArray(arr) {\n  return (\n       arr instanceof Int8Array\n    || arr instanceof Int16Array\n    || arr instanceof Int32Array\n    || arr instanceof Uint8Array\n    || arr instanceof Uint8ClampedArray\n    || arr instanceof Uint16Array\n    || arr instanceof Uint32Array\n    || arr instanceof Float32Array\n    || arr instanceof Float64Array\n  )\n}\n\nfunction isLooseTypedArray(arr) {\n  return names[toString.call(arr)]\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/is-typedarray/index.js?");

/***/ }),

/***/ "./node_modules/ms/index.js":
/*!**********************************!*\
  !*** ./node_modules/ms/index.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/ms/index.js?");

/***/ }),

/***/ "./node_modules/typedarray-to-buffer/index.js":
/*!****************************************************!*\
  !*** ./node_modules/typedarray-to-buffer/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/**\n * Convert a typed array to a Buffer without a copy\n *\n * Author:   Feross Aboukhadijeh <https://feross.org>\n * License:  MIT\n *\n * `npm install typedarray-to-buffer`\n */\n\nvar isTypedArray = __webpack_require__(/*! is-typedarray */ \"./node_modules/is-typedarray/index.js\").strict\n\nmodule.exports = function typedarrayToBuffer (arr) {\n  if (isTypedArray(arr)) {\n    // To avoid a copy, use the typed array's underlying ArrayBuffer to back new Buffer\n    var buf = Buffer.from(arr.buffer)\n    if (arr.byteLength !== arr.buffer.byteLength) {\n      // Respect the \"view\", i.e. byteOffset and byteLength, without doing a copy\n      buf = buf.slice(arr.byteOffset, arr.byteOffset + arr.byteLength)\n    }\n    return buf\n  } else {\n    // Pass through all other types to `Buffer.from`\n    return Buffer.from(arr)\n  }\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/typedarray-to-buffer/index.js?");

/***/ }),

/***/ "./node_modules/websocket/index.js":
/*!*****************************************!*\
  !*** ./node_modules/websocket/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ./lib/websocket */ \"./node_modules/websocket/lib/websocket.js\");\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/index.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/BufferUtil.fallback.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/BufferUtil.fallback.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * Copied from:\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\n/* jshint -W086 */\n\nmodule.exports.BufferUtil = {\n  merge: function(mergedBuffer, buffers) {\n    var offset = 0;\n    for (var i = 0, l = buffers.length; i < l; ++i) {\n      var buf = buffers[i];\n      buf.copy(mergedBuffer, offset);\n      offset += buf.length;\n    }\n  },\n  mask: function(source, mask, output, offset, length) {\n    var maskNum = mask.readUInt32LE(0);\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ source.readUInt32LE(i);\n      if (num < 0) { num = 4294967296 + num; }\n      output.writeUInt32LE(num, offset + i);\n    }\n    switch (length % 4) {\n      case 3: output[offset + i + 2] = source[i + 2] ^ mask[2];\n      case 2: output[offset + i + 1] = source[i + 1] ^ mask[1];\n      case 1: output[offset + i] = source[i] ^ mask[0];\n      case 0:\n    }\n  },\n  unmask: function(data, mask) {\n    var maskNum = mask.readUInt32LE(0);\n    var length = data.length;\n    var i = 0;\n    for (; i < length - 3; i += 4) {\n      var num = maskNum ^ data.readUInt32LE(i);\n      if (num < 0) { num = 4294967296 + num; }\n      data.writeUInt32LE(num, i);\n    }\n    switch (length % 4) {\n      case 3: data[i + 2] = data[i + 2] ^ mask[2];\n      case 2: data[i + 1] = data[i + 1] ^ mask[1];\n      case 1: data[i] = data[i] ^ mask[0];\n      case 0:\n    }\n  }\n};\n\n/* jshint +W086 */\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/BufferUtil.fallback.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/BufferUtil.js":
/*!**************************************************!*\
  !*** ./node_modules/websocket/lib/BufferUtil.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * Copied from:\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n  module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../build/Release/bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) { try {\n  module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../build/default/bufferutil'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) { try {\n  module.exports = __webpack_require__(/*! ./BufferUtil.fallback */ \"./node_modules/websocket/lib/BufferUtil.fallback.js\");\n} catch (e) {\n  console.error('bufferutil.node seems to not have been built. Run npm install.');\n  throw e;\n}}}\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/BufferUtil.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/Deprecation.js":
/*!***************************************************!*\
  !*** ./node_modules/websocket/lib/Deprecation.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar Deprecation = {\n    disableWarnings: false,\n\n    deprecationWarningMap: {\n\n    },\n\n    warn: function(deprecationName) {\n        if (!this.disableWarnings && this.deprecationWarningMap[deprecationName]) {\n            console.warn('DEPRECATION WARNING: ' + this.deprecationWarningMap[deprecationName]);\n            this.deprecationWarningMap[deprecationName] = false;\n        }\n    }\n};\n\nmodule.exports = Deprecation;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/Deprecation.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/Validation.fallback.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/Validation.fallback.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*!\n * UTF-8 Validation Fallback Code originally from:\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\nmodule.exports.Validation = {\n  isValidUTF8: function() {\n    return true;\n  }\n};\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/Validation.fallback.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/Validation.js":
/*!**************************************************!*\
  !*** ./node_modules/websocket/lib/Validation.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*!\n * UTF-8 Validation Code originally from:\n * ws: a node.js websocket client\n * Copyright(c) 2011 Einar Otto Stangvik <einaros@gmail.com>\n * MIT Licensed\n */\n\ntry {\n    module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../build/Release/validation'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) { try {\n    module.exports = __webpack_require__(!(function webpackMissingModule() { var e = new Error(\"Cannot find module '../build/default/validation'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));\n} catch (e) { try {\n    module.exports = __webpack_require__(/*! ./Validation.fallback */ \"./node_modules/websocket/lib/Validation.fallback.js\");\n} catch (e) {\n    console.error('validation.node seems not to have been built. Run npm install.');\n    throw e;\n}}}\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/Validation.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/W3CWebSocket.js":
/*!****************************************************!*\
  !*** ./node_modules/websocket/lib/W3CWebSocket.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar WebSocketClient = __webpack_require__(/*! ./WebSocketClient */ \"./node_modules/websocket/lib/WebSocketClient.js\");\nvar toBuffer = __webpack_require__(/*! typedarray-to-buffer */ \"./node_modules/typedarray-to-buffer/index.js\");\nvar yaeti = __webpack_require__(/*! yaeti */ \"./node_modules/yaeti/index.js\");\n\n\nconst CONNECTING = 0;\nconst OPEN = 1;\nconst CLOSING = 2;\nconst CLOSED = 3;\n\n\nmodule.exports = W3CWebSocket;\n\n\nfunction W3CWebSocket(url, protocols, origin, headers, requestOptions, clientConfig) {\n    // Make this an EventTarget.\n    yaeti.EventTarget.call(this);\n\n    // Sanitize clientConfig.\n    clientConfig = clientConfig || {};\n    clientConfig.assembleFragments = true;  // Required in the W3C API.\n\n    var self = this;\n\n    this._url = url;\n    this._readyState = CONNECTING;\n    this._protocol = undefined;\n    this._extensions = '';\n    this._bufferedAmount = 0;  // Hack, always 0.\n    this._binaryType = 'arraybuffer';  // TODO: Should be 'blob' by default, but Node has no Blob.\n\n    // The WebSocketConnection instance.\n    this._connection = undefined;\n\n    // WebSocketClient instance.\n    this._client = new WebSocketClient(clientConfig);\n\n    this._client.on('connect', function(connection) {\n        onConnect.call(self, connection);\n    });\n\n    this._client.on('connectFailed', function() {\n        onConnectFailed.call(self);\n    });\n\n    this._client.connect(url, protocols, origin, headers, requestOptions);\n}\n\n\n// Expose W3C read only attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    url:            { get: function() { return this._url;            } },\n    readyState:     { get: function() { return this._readyState;     } },\n    protocol:       { get: function() { return this._protocol;       } },\n    extensions:     { get: function() { return this._extensions;     } },\n    bufferedAmount: { get: function() { return this._bufferedAmount; } }\n});\n\n\n// Expose W3C write/read attributes.\nObject.defineProperties(W3CWebSocket.prototype, {\n    binaryType: {\n        get: function() {\n            return this._binaryType;\n        },\n        set: function(type) {\n            // TODO: Just 'arraybuffer' supported.\n            if (type !== 'arraybuffer') {\n                throw new SyntaxError('just \"arraybuffer\" type allowed for \"binaryType\" attribute');\n            }\n            this._binaryType = type;\n        }\n    }\n});\n\n\n// Expose W3C readyState constants into the WebSocket instance as W3C states.\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket.prototype, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n// Also expose W3C readyState constants into the WebSocket class (not defined by the W3C,\n// but there are so many libs relying on them).\n[['CONNECTING',CONNECTING], ['OPEN',OPEN], ['CLOSING',CLOSING], ['CLOSED',CLOSED]].forEach(function(property) {\n    Object.defineProperty(W3CWebSocket, property[0], {\n        get: function() { return property[1]; }\n    });\n});\n\n\nW3CWebSocket.prototype.send = function(data) {\n    if (this._readyState !== OPEN) {\n        throw new Error('cannot call send() while not connected');\n    }\n\n    // Text.\n    if (typeof data === 'string' || data instanceof String) {\n        this._connection.sendUTF(data);\n    }\n    // Binary.\n    else {\n        // Node Buffer.\n        if (data instanceof Buffer) {\n            this._connection.sendBytes(data);\n        }\n        // If ArrayBuffer or ArrayBufferView convert it to Node Buffer.\n        else if (data.byteLength || data.byteLength === 0) {\n            data = toBuffer(data);\n            this._connection.sendBytes(data);\n        }\n        else {\n            throw new Error('unknown binary data:', data);\n        }\n    }\n};\n\n\nW3CWebSocket.prototype.close = function(code, reason) {\n    switch(this._readyState) {\n        case CONNECTING:\n            // NOTE: We don't have the WebSocketConnection instance yet so no\n            // way to close the TCP connection.\n            // Artificially invoke the onConnectFailed event.\n            onConnectFailed.call(this);\n            // And close if it connects after a while.\n            this._client.on('connect', function(connection) {\n                if (code) {\n                    connection.close(code, reason);\n                } else {\n                    connection.close();\n                }\n            });\n            break;\n        case OPEN:\n            this._readyState = CLOSING;\n            if (code) {\n                this._connection.close(code, reason);\n            } else {\n                this._connection.close();\n            }\n            break;\n        case CLOSING:\n        case CLOSED:\n            break;\n    }\n};\n\n\n/**\n * Private API.\n */\n\n\nfunction createCloseEvent(code, reason) {\n    var event = new yaeti.Event('close');\n\n    event.code = code;\n    event.reason = reason;\n    event.wasClean = (typeof code === 'undefined' || code === 1000);\n\n    return event;\n}\n\n\nfunction createMessageEvent(data) {\n    var event = new yaeti.Event('message');\n\n    event.data = data;\n\n    return event;\n}\n\n\nfunction onConnect(connection) {\n    var self = this;\n\n    this._readyState = OPEN;\n    this._connection = connection;\n    this._protocol = connection.protocol;\n    this._extensions = connection.extensions;\n\n    this._connection.on('close', function(code, reason) {\n        onClose.call(self, code, reason);\n    });\n\n    this._connection.on('message', function(msg) {\n        onMessage.call(self, msg);\n    });\n\n    this.dispatchEvent(new yaeti.Event('open'));\n}\n\n\nfunction onConnectFailed() {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    try {\n        this.dispatchEvent(new yaeti.Event('error'));\n    } finally {\n        this.dispatchEvent(createCloseEvent(1006, 'connection failed'));\n    }\n}\n\n\nfunction onClose(code, reason) {\n    destroy.call(this);\n    this._readyState = CLOSED;\n\n    this.dispatchEvent(createCloseEvent(code, reason || ''));\n}\n\n\nfunction onMessage(message) {\n    if (message.utf8Data) {\n        this.dispatchEvent(createMessageEvent(message.utf8Data));\n    }\n    else if (message.binaryData) {\n        // Must convert from Node Buffer to ArrayBuffer.\n        // TODO: or to a Blob (which does not exist in Node!).\n        if (this.binaryType === 'arraybuffer') {\n            var buffer = message.binaryData;\n            var arraybuffer = new ArrayBuffer(buffer.length);\n            var view = new Uint8Array(arraybuffer);\n            for (var i=0, len=buffer.length; i<len; ++i) {\n                view[i] = buffer[i];\n            }\n            this.dispatchEvent(createMessageEvent(arraybuffer));\n        }\n    }\n}\n\n\nfunction destroy() {\n    this._client.removeAllListeners();\n    if (this._connection) {\n        this._connection.removeAllListeners();\n    }\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/W3CWebSocket.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketClient.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketClient.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\");\nvar extend = utils.extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar http = __webpack_require__(/*! http */ \"http\");\nvar https = __webpack_require__(/*! https */ \"https\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"./node_modules/websocket/lib/WebSocketConnection.js\");\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\n\nvar protocolSeparators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\n\nvar excludedTlsOptions = ['hostname','port','method','path','headers'];\n\nfunction WebSocketClient(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    // TODO: Implement extensions\n\n    this.config = {\n        // 1MiB max frame size.\n        maxReceivedFrameSize: 0x100000,\n\n        // 8MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x800000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // Which version of the protocol to use for this session.  This\n        // option will be removed once the protocol is finalized by the IETF\n        // It is only available to ease the transition through the\n        // intermediate draft protocol versions.\n        // At present, it only affects the name of the Origin header.\n        webSocketVersion: 13,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000,\n\n        // Options to pass to https.connect if connecting via TLS\n        tlsOptions: {}\n    };\n\n    if (config) {\n        var tlsOptions;\n        if (config.tlsOptions) {\n          tlsOptions = config.tlsOptions;\n          delete config.tlsOptions;\n        }\n        else {\n          tlsOptions = {};\n        }\n        extend(this.config, config);\n        extend(this.config.tlsOptions, tlsOptions);\n    }\n\n    this._req = null;\n    \n    switch (this.config.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            throw new Error('Requested webSocketVersion is not supported. Allowed values are 8 and 13.');\n    }\n}\n\nutil.inherits(WebSocketClient, EventEmitter);\n\nWebSocketClient.prototype.connect = function(requestUrl, protocols, origin, headers, extraRequestOptions) {\n    var self = this;\n    \n    if (typeof(protocols) === 'string') {\n        if (protocols.length > 0) {\n            protocols = [protocols];\n        }\n        else {\n            protocols = [];\n        }\n    }\n    if (!(protocols instanceof Array)) {\n        protocols = [];\n    }\n    this.protocols = protocols;\n    this.origin = origin;\n\n    if (typeof(requestUrl) === 'string') {\n        this.url = url.parse(requestUrl);\n    }\n    else {\n        this.url = requestUrl; // in case an already parsed url is passed in.\n    }\n    if (!this.url.protocol) {\n        throw new Error('You must specify a full WebSocket URL, including protocol.');\n    }\n    if (!this.url.host) {\n        throw new Error('You must specify a full WebSocket URL, including hostname. Relative URLs are not supported.');\n    }\n\n    this.secure = (this.url.protocol === 'wss:');\n\n    // validate protocol characters:\n    this.protocols.forEach(function(protocol) {\n        for (var i=0; i < protocol.length; i ++) {\n            var charCode = protocol.charCodeAt(i);\n            var character = protocol.charAt(i);\n            if (charCode < 0x0021 || charCode > 0x007E || protocolSeparators.indexOf(character) !== -1) {\n                throw new Error('Protocol list contains invalid character \"' + String.fromCharCode(charCode) + '\"');\n            }\n        }\n    });\n\n    var defaultPorts = {\n        'ws:': '80',\n        'wss:': '443'\n    };\n\n    if (!this.url.port) {\n        this.url.port = defaultPorts[this.url.protocol];\n    }\n\n    var nonce = bufferAllocUnsafe(16);\n    for (var i=0; i < 16; i++) {\n        nonce[i] = Math.round(Math.random()*0xFF);\n    }\n    this.base64nonce = nonce.toString('base64');\n\n    var hostHeaderValue = this.url.hostname;\n    if ((this.url.protocol === 'ws:' && this.url.port !== '80') ||\n        (this.url.protocol === 'wss:' && this.url.port !== '443'))  {\n        hostHeaderValue += (':' + this.url.port);\n    }\n\n    var reqHeaders = {};\n    if (this.secure && this.config.tlsOptions.hasOwnProperty('headers')) {\n      // Allow for additional headers to be provided when connecting via HTTPS\n      extend(reqHeaders, this.config.tlsOptions.headers);\n    }\n    if (headers) {\n      // Explicitly provided headers take priority over any from tlsOptions\n      extend(reqHeaders, headers);\n    }\n    extend(reqHeaders, {\n        'Upgrade': 'websocket',\n        'Connection': 'Upgrade',\n        'Sec-WebSocket-Version': this.config.webSocketVersion.toString(10),\n        'Sec-WebSocket-Key': this.base64nonce,\n        'Host': reqHeaders.Host || hostHeaderValue\n    });\n\n    if (this.protocols.length > 0) {\n        reqHeaders['Sec-WebSocket-Protocol'] = this.protocols.join(', ');\n    }\n    if (this.origin) {\n        if (this.config.webSocketVersion === 13) {\n            reqHeaders['Origin'] = this.origin;\n        }\n        else if (this.config.webSocketVersion === 8) {\n            reqHeaders['Sec-WebSocket-Origin'] = this.origin;\n        }\n    }\n\n    // TODO: Implement extensions\n\n    var pathAndQuery;\n    // Ensure it begins with '/'.\n    if (this.url.pathname) {\n        pathAndQuery = this.url.path;\n    }\n    else if (this.url.path) {\n        pathAndQuery = '/' + this.url.path;\n    }\n    else {\n        pathAndQuery = '/';\n    }\n\n    function handleRequestError(error) {\n        self._req = null;\n        self.emit('connectFailed', error);\n    }\n\n    var requestOptions = {\n        agent: false\n    };\n    if (extraRequestOptions) {\n        extend(requestOptions, extraRequestOptions);\n    }\n    // These options are always overridden by the library.  The user is not\n    // allowed to specify these directly.\n    extend(requestOptions, {\n        hostname: this.url.hostname,\n        port: this.url.port,\n        method: 'GET',\n        path: pathAndQuery,\n        headers: reqHeaders\n    });\n    if (this.secure) {\n        var tlsOptions = this.config.tlsOptions;\n        for (var key in tlsOptions) {\n            if (tlsOptions.hasOwnProperty(key) && excludedTlsOptions.indexOf(key) === -1) {\n                requestOptions[key] = tlsOptions[key];\n            }\n        }\n    }\n\n    var req = this._req = (this.secure ? https : http).request(requestOptions);\n    req.on('upgrade', function handleRequestUpgrade(response, socket, head) {\n        self._req = null;\n        req.removeListener('error', handleRequestError);\n        self.socket = socket;\n        self.response = response;\n        self.firstDataChunk = head;\n        self.validateHandshake();\n    });\n    req.on('error', handleRequestError);\n\n    req.on('response', function(response) {\n        self._req = null;\n        if (utils.eventEmitterListenerCount(self, 'httpResponse') > 0) {\n            self.emit('httpResponse', response, self);\n            if (response.socket) {\n                response.socket.end();\n            }\n        }\n        else {\n            var headerDumpParts = [];\n            for (var headerName in response.headers) {\n                headerDumpParts.push(headerName + ': ' + response.headers[headerName]);\n            }\n            self.failHandshake(\n                'Server responded with a non-101 status: ' +\n                response.statusCode + ' ' + response.statusMessage +\n                '\\nResponse Headers Follow:\\n' +\n                headerDumpParts.join('\\n') + '\\n'\n            );\n        }\n    });\n    req.end();\n};\n\nWebSocketClient.prototype.validateHandshake = function() {\n    var headers = this.response.headers;\n\n    if (this.protocols.length > 0) {\n        this.protocol = headers['sec-websocket-protocol'];\n        if (this.protocol) {\n            if (this.protocols.indexOf(this.protocol) === -1) {\n                this.failHandshake('Server did not respond with a requested protocol.');\n                return;\n            }\n        }\n        else {\n            this.failHandshake('Expected a Sec-WebSocket-Protocol header.');\n            return;\n        }\n    }\n\n    if (!(headers['connection'] && headers['connection'].toLocaleLowerCase() === 'upgrade')) {\n        this.failHandshake('Expected a Connection: Upgrade header from the server');\n        return;\n    }\n\n    if (!(headers['upgrade'] && headers['upgrade'].toLocaleLowerCase() === 'websocket')) {\n        this.failHandshake('Expected an Upgrade: websocket header from the server');\n        return;\n    }\n\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.base64nonce + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var expectedKey = sha1.digest('base64');\n\n    if (!headers['sec-websocket-accept']) {\n        this.failHandshake('Expected Sec-WebSocket-Accept header from server');\n        return;\n    }\n\n    if (headers['sec-websocket-accept'] !== expectedKey) {\n        this.failHandshake('Sec-WebSocket-Accept header from server didn\\'t match expected value of ' + expectedKey);\n        return;\n    }\n\n    // TODO: Support extensions\n\n    this.succeedHandshake();\n};\n\nWebSocketClient.prototype.failHandshake = function(errorDescription) {\n    if (this.socket && this.socket.writable) {\n        this.socket.end();\n    }\n    this.emit('connectFailed', new Error(errorDescription));\n};\n\nWebSocketClient.prototype.succeedHandshake = function() {\n    var connection = new WebSocketConnection(this.socket, [], this.protocol, true, this.config);\n\n    connection.webSocketVersion = this.config.webSocketVersion;\n    connection._addSocketEventListeners();\n\n    this.emit('connect', connection);\n    if (this.firstDataChunk.length > 0) {\n        connection.handleSocketData(this.firstDataChunk);\n    }\n    this.firstDataChunk = null;\n};\n\nWebSocketClient.prototype.abort = function() {\n    if (this._req) {\n        this._req.abort();\n    }\n};\n\nmodule.exports = WebSocketClient;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketClient.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketConnection.js":
/*!***********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketConnection.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar WebSocketFrame = __webpack_require__(/*! ./WebSocketFrame */ \"./node_modules/websocket/lib/WebSocketFrame.js\");\nvar BufferList = __webpack_require__(/*! ../vendor/FastBufferList */ \"./node_modules/websocket/vendor/FastBufferList.js\");\nvar Validation = __webpack_require__(/*! ./Validation */ \"./node_modules/websocket/lib/Validation.js\").Validation;\nvar bufferAllocUnsafe = utils.bufferAllocUnsafe;\nvar bufferFromString = utils.bufferFromString;\n\n// Connected, fully-open, ready to send and receive frames\nconst STATE_OPEN = 'open';\n// Received a close frame from the remote peer\nconst STATE_PEER_REQUESTED_CLOSE = 'peer_requested_close';\n// Sent close frame to remote peer.  No further data can be sent.\nconst STATE_ENDING = 'ending';\n// Connection is fully closed.  No further data can be sent or received.\nconst STATE_CLOSED = 'closed';\n\nvar setImmediateImpl = ('setImmediate' in global) ?\n                            global.setImmediate.bind(global) :\n                            process.nextTick.bind(process);\n\nvar idCounter = 0;\n\nfunction WebSocketConnection(socket, extensions, protocol, maskOutgoingPackets, config) {\n    this._debug = utils.BufferingLogger('websocket:connection', ++idCounter);\n    this._debug('constructor');\n    \n    if (this._debug.enabled) {\n        instrumentSocketForDebugging(this, socket);\n    }\n    \n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._pingListenerCount = 0;\n    this.on('newListener', function(ev) {\n        if (ev === 'ping'){\n            this._pingListenerCount++;\n        }\n      }).on('removeListener', function(ev) {\n        if (ev === 'ping') {\n            this._pingListenerCount--;\n        }\n    });\n\n    this.config = config;\n    this.socket = socket;\n    this.protocol = protocol;\n    this.extensions = extensions;\n    this.remoteAddress = socket.remoteAddress;\n    this.closeReasonCode = -1;\n    this.closeDescription = null;\n    this.closeEventEmitted = false;\n\n    // We have to mask outgoing packets if we're acting as a WebSocket client.\n    this.maskOutgoingPackets = maskOutgoingPackets;\n\n    // We re-use the same buffers for the mask and frame header for all frames\n    // received on each connection to avoid a small memory allocation for each\n    // frame.\n    this.maskBytes = bufferAllocUnsafe(4);\n    this.frameHeader = bufferAllocUnsafe(10);\n\n    // the BufferList will handle the data streaming in\n    this.bufferList = new BufferList();\n\n    // Prepare for receiving first frame\n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    this.fragmentationSize = 0; // data received so far...\n    this.frameQueue = [];\n    \n    // Various bits of connection state\n    this.connected = true;\n    this.state = STATE_OPEN;\n    this.waitingForCloseResponse = false;\n    // Received TCP FIN, socket's readable stream is finished.\n    this.receivedEnd = false;\n\n    this.closeTimeout = this.config.closeTimeout;\n    this.assembleFragments = this.config.assembleFragments;\n    this.maxReceivedMessageSize = this.config.maxReceivedMessageSize;\n\n    this.outputBufferFull = false;\n    this.inputPaused = false;\n    this.receivedDataHandler = this.processReceivedData.bind(this);\n    this._closeTimerHandler = this.handleCloseTimer.bind(this);\n\n    // Disable nagle algorithm?\n    this.socket.setNoDelay(this.config.disableNagleAlgorithm);\n\n    // Make sure there is no socket inactivity timeout\n    this.socket.setTimeout(0);\n\n    if (this.config.keepalive && !this.config.useNativeKeepalive) {\n        if (typeof(this.config.keepaliveInterval) !== 'number') {\n            throw new Error('keepaliveInterval must be specified and numeric ' +\n                            'if keepalive is true.');\n        }\n        this._keepaliveTimerHandler = this.handleKeepaliveTimer.bind(this);\n        this.setKeepaliveTimer();\n\n        if (this.config.dropConnectionOnKeepaliveTimeout) {\n            if (typeof(this.config.keepaliveGracePeriod) !== 'number') {\n                throw new Error('keepaliveGracePeriod  must be specified and ' +\n                                'numeric if dropConnectionOnKeepaliveTimeout ' +\n                                'is true.');\n            }\n            this._gracePeriodTimerHandler = this.handleGracePeriodTimer.bind(this);\n        }\n    }\n    else if (this.config.keepalive && this.config.useNativeKeepalive) {\n        if (!('setKeepAlive' in this.socket)) {\n            throw new Error('Unable to use native keepalive: unsupported by ' +\n                            'this version of Node.');\n        }\n        this.socket.setKeepAlive(true, this.config.keepaliveInterval);\n    }\n    \n    // The HTTP Client seems to subscribe to socket error events\n    // and re-dispatch them in such a way that doesn't make sense\n    // for users of our client, so we want to make sure nobody\n    // else is listening for error events on the socket besides us.\n    this.socket.removeAllListeners('error');\n}\n\nWebSocketConnection.CLOSE_REASON_NORMAL = 1000;\nWebSocketConnection.CLOSE_REASON_GOING_AWAY = 1001;\nWebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR = 1002;\nWebSocketConnection.CLOSE_REASON_UNPROCESSABLE_INPUT = 1003;\nWebSocketConnection.CLOSE_REASON_RESERVED = 1004; // Reserved value.  Undefined meaning.\nWebSocketConnection.CLOSE_REASON_NOT_PROVIDED = 1005; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_ABNORMAL = 1006; // Not to be used on the wire\nWebSocketConnection.CLOSE_REASON_INVALID_DATA = 1007;\nWebSocketConnection.CLOSE_REASON_POLICY_VIOLATION = 1008;\nWebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG = 1009;\nWebSocketConnection.CLOSE_REASON_EXTENSION_REQUIRED = 1010;\nWebSocketConnection.CLOSE_REASON_INTERNAL_SERVER_ERROR = 1011;\nWebSocketConnection.CLOSE_REASON_TLS_HANDSHAKE_FAILED = 1015; // Not to be used on the wire\n\nWebSocketConnection.CLOSE_DESCRIPTIONS = {\n    1000: 'Normal connection closure',\n    1001: 'Remote peer is going away',\n    1002: 'Protocol error',\n    1003: 'Unprocessable input',\n    1004: 'Reserved',\n    1005: 'Reason not provided',\n    1006: 'Abnormal closure, no further detail available',\n    1007: 'Invalid data received',\n    1008: 'Policy violation',\n    1009: 'Message too big',\n    1010: 'Extension requested by client is required',\n    1011: 'Internal Server Error',\n    1015: 'TLS Handshake Failed'\n};\n\nfunction validateCloseReason(code) {\n    if (code < 1000) {\n        // Status codes in the range 0-999 are not used\n        return false;\n    }\n    if (code >= 1000 && code <= 2999) {\n        // Codes from 1000 - 2999 are reserved for use by the protocol.  Only\n        // a few codes are defined, all others are currently illegal.\n        return [1000, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011, 1012, 1013, 1014].indexOf(code) !== -1;\n    }\n    if (code >= 3000 && code <= 3999) {\n        // Reserved for use by libraries, frameworks, and applications.\n        // Should be registered with IANA.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 4000 && code <= 4999) {\n        // Reserved for private use.  Interpretation of these codes is\n        // undefined by the WebSocket protocol.\n        return true;\n    }\n    if (code >= 5000) {\n        return false;\n    }\n}\n\nutil.inherits(WebSocketConnection, EventEmitter);\n\nWebSocketConnection.prototype._addSocketEventListeners = function() {\n    this.socket.on('error', this.handleSocketError.bind(this));\n    this.socket.on('end', this.handleSocketEnd.bind(this));\n    this.socket.on('close', this.handleSocketClose.bind(this));\n    this.socket.on('drain', this.handleSocketDrain.bind(this));\n    this.socket.on('pause', this.handleSocketPause.bind(this));\n    this.socket.on('resume', this.handleSocketResume.bind(this));\n    this.socket.on('data', this.handleSocketData.bind(this));\n};\n\n// set or reset the keepalive timer when data is received.\nWebSocketConnection.prototype.setKeepaliveTimer = function() {\n    this._debug('setKeepaliveTimer');\n    if (!this.config.keepalive  || this.config.useNativeKeepalive) { return; }\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    this._keepaliveTimeoutID = setTimeout(this._keepaliveTimerHandler, this.config.keepaliveInterval);\n};\n\nWebSocketConnection.prototype.clearKeepaliveTimer = function() {\n    if (this._keepaliveTimeoutID) {\n        clearTimeout(this._keepaliveTimeoutID);\n    }\n};\n\n// No data has been received within config.keepaliveTimeout ms.\nWebSocketConnection.prototype.handleKeepaliveTimer = function() {\n    this._debug('handleKeepaliveTimer');\n    this._keepaliveTimeoutID = null;\n    this.ping();\n\n    // If we are configured to drop connections if the client doesn't respond\n    // then set the grace period timer.\n    if (this.config.dropConnectionOnKeepaliveTimeout) {\n        this.setGracePeriodTimer();\n    }\n    else {\n        // Otherwise reset the keepalive timer to send the next ping.\n        this.setKeepaliveTimer();\n    }\n};\n\nWebSocketConnection.prototype.setGracePeriodTimer = function() {\n    this._debug('setGracePeriodTimer');\n    this.clearGracePeriodTimer();\n    this._gracePeriodTimeoutID = setTimeout(this._gracePeriodTimerHandler, this.config.keepaliveGracePeriod);\n};\n\nWebSocketConnection.prototype.clearGracePeriodTimer = function() {\n    if (this._gracePeriodTimeoutID) {\n        clearTimeout(this._gracePeriodTimeoutID);\n    }\n};\n\nWebSocketConnection.prototype.handleGracePeriodTimer = function() {\n    this._debug('handleGracePeriodTimer');\n    // If this is called, the client has not responded and is assumed dead.\n    this._gracePeriodTimeoutID = null;\n    this.drop(WebSocketConnection.CLOSE_REASON_ABNORMAL, 'Peer not responding.', true);\n};\n\nWebSocketConnection.prototype.handleSocketData = function(data) {\n    this._debug('handleSocketData');\n    // Reset the keepalive timer when receiving data of any kind.\n    this.setKeepaliveTimer();\n\n    // Add received data to our bufferList, which efficiently holds received\n    // data chunks in a linked list of Buffer objects.\n    this.bufferList.write(data);\n\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.processReceivedData = function() {\n    this._debug('processReceivedData');\n    // If we're not connected, we should ignore any data remaining on the buffer.\n    if (!this.connected) { return; }\n\n    // Receiving/parsing is expected to be halted when paused.\n    if (this.inputPaused) { return; }\n\n    var frame = this.currentFrame;\n\n    // WebSocketFrame.prototype.addData returns true if all data necessary to\n    // parse the frame was available.  It returns false if we are waiting for\n    // more data to come in on the wire.\n    if (!frame.addData(this.bufferList)) { this._debug('-- insufficient data for frame'); return; }\n\n    var self = this;\n\n    // Handle possible parsing errors\n    if (frame.protocolError) {\n        // Something bad happened.. get rid of this client.\n        this._debug('-- protocol error');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR, frame.dropReason);\n        });\n        return;\n    }\n    else if (frame.frameTooLarge) {\n        this._debug('-- frame too large');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG, frame.dropReason);\n        });\n        return;\n    }\n\n    // For now since we don't support extensions, all RSV bits are illegal\n    if (frame.rsv1 || frame.rsv2 || frame.rsv3) {\n        this._debug('-- illegal rsv flag');\n        process.nextTick(function() {\n            self.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unsupported usage of rsv bits without negotiated extension.');\n        });\n        return;\n    }\n\n    if (!this.assembleFragments) {\n        this._debug('-- emitting frame');\n        process.nextTick(function() { self.emit('frame', frame); });\n    }\n\n    process.nextTick(function() { self.processFrame(frame); });\n    \n    this.currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n\n    // If there's data remaining, schedule additional processing, but yield\n    // for now so that other connections have a chance to have their data\n    // processed.  We use setImmediate here instead of process.nextTick to\n    // explicitly indicate that we wish for other I/O to be handled first.\n    if (this.bufferList.length > 0) {\n        setImmediateImpl(this.receivedDataHandler);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketError = function(error) {\n    this._debug('handleSocketError: %j', error);\n    if (this.state === STATE_CLOSED) {\n\t\t// See https://github.com/theturtle32/WebSocket-Node/issues/288\n        this._debug('  --- Socket \\'error\\' after \\'close\\'');\n        return;\n    }\n    this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n    this.closeDescription = 'Socket Error: ' + error.syscall + ' ' + error.code;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.fragmentationSize = 0;\n    if (utils.eventEmitterListenerCount(this, 'error') > 0) {\n        this.emit('error', error);\n    }\n    this.socket.destroy(error);\n    this._debug.printOutput();\n};\n\nWebSocketConnection.prototype.handleSocketEnd = function() {\n    this._debug('handleSocketEnd: received socket end.  state = %s', this.state);\n    this.receivedEnd = true;\n    if (this.state === STATE_CLOSED) {\n        // When using the TLS module, sometimes the socket will emit 'end'\n        // after it emits 'close'.  I don't think that's correct behavior,\n        // but we should deal with it gracefully by ignoring it.\n        this._debug('  --- Socket \\'end\\' after \\'close\\'');\n        return;\n    }\n    if (this.state !== STATE_PEER_REQUESTED_CLOSE &&\n        this.state !== STATE_ENDING) {\n      this._debug('  --- UNEXPECTED socket end.');\n      this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.handleSocketClose = function(hadError) {\n    this._debug('handleSocketClose: received socket close');\n    this.socketHadError = hadError;\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    // If closeReasonCode is still set to -1 at this point then we must\n    // not have received a close frame!!\n    if (this.closeReasonCode === -1) {\n        this.closeReasonCode = WebSocketConnection.CLOSE_REASON_ABNORMAL;\n        this.closeDescription = 'Connection dropped by remote peer.';\n    }\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('-- Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n};\n\nWebSocketConnection.prototype.handleSocketDrain = function() {\n    this._debug('handleSocketDrain: socket drain event');\n    this.outputBufferFull = false;\n    this.emit('drain');\n};\n\nWebSocketConnection.prototype.handleSocketPause = function() {\n    this._debug('handleSocketPause: socket pause event');\n    this.inputPaused = true;\n    this.emit('pause');\n};\n\nWebSocketConnection.prototype.handleSocketResume = function() {\n    this._debug('handleSocketResume: socket resume event');\n    this.inputPaused = false;\n    this.emit('resume');\n    this.processReceivedData();\n};\n\nWebSocketConnection.prototype.pause = function() {\n    this._debug('pause: pause requested');\n    this.socket.pause();\n};\n\nWebSocketConnection.prototype.resume = function() {\n    this._debug('resume: resume requested');\n    this.socket.resume();\n};\n\nWebSocketConnection.prototype.close = function(reasonCode, description) {\n    if (this.connected) {\n        this._debug('close: Initating clean WebSocket close sequence.');\n        if ('number' !== typeof reasonCode) {\n            reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n        }\n        if (!validateCloseReason(reasonCode)) {\n            throw new Error('Close code ' + reasonCode + ' is not valid.');\n        }\n        if ('string' !== typeof description) {\n            description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n        }\n        this.closeReasonCode = reasonCode;\n        this.closeDescription = description;\n        this.setCloseTimer();\n        this.sendCloseFrame(this.closeReasonCode, this.closeDescription);\n        this.state = STATE_ENDING;\n        this.connected = false;\n    }\n};\n\nWebSocketConnection.prototype.drop = function(reasonCode, description, skipCloseFrame) {\n    this._debug('drop');\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n    }\n\n    if (typeof(description) !== 'string') {\n        // If no description is provided, try to look one up based on the\n        // specified reasonCode.\n        description = WebSocketConnection.CLOSE_DESCRIPTIONS[reasonCode];\n    }\n\n    this._debug('Forcefully dropping connection. skipCloseFrame: %s, code: %d, description: %s',\n        skipCloseFrame, reasonCode, description\n    );\n\n    this.closeReasonCode = reasonCode;\n    this.closeDescription = description;\n    this.frameQueue = [];\n    this.fragmentationSize = 0;\n    if (!skipCloseFrame) {\n        this.sendCloseFrame(reasonCode, description);\n    }\n    this.connected = false;\n    this.state = STATE_CLOSED;\n    this.clearCloseTimer();\n    this.clearKeepaliveTimer();\n    this.clearGracePeriodTimer();\n\n    if (!this.closeEventEmitted) {\n        this.closeEventEmitted = true;\n        this._debug('Emitting WebSocketConnection close event');\n        this.emit('close', this.closeReasonCode, this.closeDescription);\n    }\n    \n    this._debug('Drop: destroying socket');\n    this.socket.destroy();\n};\n\nWebSocketConnection.prototype.setCloseTimer = function() {\n    this._debug('setCloseTimer');\n    this.clearCloseTimer();\n    this._debug('Setting close timer');\n    this.waitingForCloseResponse = true;\n    this.closeTimer = setTimeout(this._closeTimerHandler, this.closeTimeout);\n};\n\nWebSocketConnection.prototype.clearCloseTimer = function() {\n    this._debug('clearCloseTimer');\n    if (this.closeTimer) {\n        this._debug('Clearing close timer');\n        clearTimeout(this.closeTimer);\n        this.waitingForCloseResponse = false;\n        this.closeTimer = null;\n    }\n};\n\nWebSocketConnection.prototype.handleCloseTimer = function() {\n    this._debug('handleCloseTimer');\n    this.closeTimer = null;\n    if (this.waitingForCloseResponse) {\n        this._debug('Close response not received from client.  Forcing socket end.');\n        this.waitingForCloseResponse = false;\n        this.state = STATE_CLOSED;\n        this.socket.end();\n    }\n};\n\nWebSocketConnection.prototype.processFrame = function(frame) {\n    this._debug('processFrame');\n    this._debug(' -- frame: %s', frame);\n    \n    // Any non-control opcode besides 0x00 (continuation) received in the\n    // middle of a fragmented message is illegal.\n    if (this.frameQueue.length !== 0 && (frame.opcode > 0x00 && frame.opcode < 0x08)) {\n        this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n          'Illegal frame opcode 0x' + frame.opcode.toString(16) + ' ' +\n          'received in middle of fragmented message.');\n        return;\n    }\n\n    switch(frame.opcode) {\n        case 0x02: // WebSocketFrame.BINARY_FRAME\n            this._debug('-- Binary Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'binary',\n                        binaryData: frame.binaryPayload\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x01: // WebSocketFrame.TEXT_FRAME\n            this._debug('-- Text Frame');\n            if (this.assembleFragments) {\n                if (frame.fin) {\n                    if (!Validation.isValidUTF8(frame.binaryPayload)) {\n                        this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                          'Invalid UTF-8 Data Received');\n                        return;\n                    }\n                    // Complete single-frame message received\n                    this._debug('---- Emitting \\'message\\' event');\n                    this.emit('message', {\n                        type: 'utf8',\n                        utf8Data: frame.binaryPayload.toString('utf8')\n                    });\n                }\n                else {\n                    // beginning of a fragmented message\n                    this.frameQueue.push(frame);\n                    this.fragmentationSize = frame.length;\n                }\n            }\n            break;\n        case 0x00: // WebSocketFrame.CONTINUATION\n            this._debug('-- Continuation Frame');\n            if (this.assembleFragments) {\n                if (this.frameQueue.length === 0) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                      'Unexpected Continuation Frame');\n                    return;\n                }\n\n                this.fragmentationSize += frame.length;\n\n                if (this.fragmentationSize > this.maxReceivedMessageSize) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_MESSAGE_TOO_BIG,\n                      'Maximum message size exceeded.');\n                    return;\n                }\n\n                this.frameQueue.push(frame);\n\n                if (frame.fin) {\n                    // end of fragmented message, so we process the whole\n                    // message now.  We also have to decode the utf-8 data\n                    // for text frames after combining all the fragments.\n                    var bytesCopied = 0;\n                    var binaryPayload = bufferAllocUnsafe(this.fragmentationSize);\n                    var opcode = this.frameQueue[0].opcode;\n                    this.frameQueue.forEach(function (currentFrame) {\n                        currentFrame.binaryPayload.copy(binaryPayload, bytesCopied);\n                        bytesCopied += currentFrame.binaryPayload.length;\n                    });\n                    this.frameQueue = [];\n                    this.fragmentationSize = 0;\n\n                    switch (opcode) {\n                        case 0x02: // WebSocketOpcode.BINARY_FRAME\n                            this.emit('message', {\n                                type: 'binary',\n                                binaryData: binaryPayload\n                            });\n                            break;\n                        case 0x01: // WebSocketOpcode.TEXT_FRAME\n                            if (!Validation.isValidUTF8(binaryPayload)) {\n                                this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                                  'Invalid UTF-8 Data Received');\n                                return;\n                            }\n                            this.emit('message', {\n                                type: 'utf8',\n                                utf8Data: binaryPayload.toString('utf8')\n                            });\n                            break;\n                        default:\n                            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n                              'Unexpected first opcode in fragmentation sequence: 0x' + opcode.toString(16));\n                            return;\n                    }\n                }\n            }\n            break;\n        case 0x09: // WebSocketFrame.PING\n            this._debug('-- Ping Frame');\n\n            if (this._pingListenerCount > 0) {\n                // logic to emit the ping frame: this is only done when a listener is known to exist\n                // Expose a function allowing the user to override the default ping() behavior\n                var cancelled = false;\n                var cancel = function() { \n                  cancelled = true; \n                };\n                this.emit('ping', cancel, frame.binaryPayload);\n\n                // Only send a pong if the client did not indicate that he would like to cancel\n                if (!cancelled) {\n                    this.pong(frame.binaryPayload);\n                }\n            }\n            else {\n                this.pong(frame.binaryPayload);\n            }\n\n            break;\n        case 0x0A: // WebSocketFrame.PONG\n            this._debug('-- Pong Frame');\n            this.emit('pong', frame.binaryPayload);\n            break;\n        case 0x08: // WebSocketFrame.CONNECTION_CLOSE\n            this._debug('-- Close Frame');\n            if (this.waitingForCloseResponse) {\n                // Got response to our request to close the connection.\n                // Close is complete, so we just hang up.\n                this._debug('---- Got close response from peer.  Completing closing handshake.');\n                this.clearCloseTimer();\n                this.waitingForCloseResponse = false;\n                this.state = STATE_CLOSED;\n                this.socket.end();\n                return;\n            }\n            \n            this._debug('---- Closing handshake initiated by peer.');\n            // Got request from other party to close connection.\n            // Send back acknowledgement and then hang up.\n            this.state = STATE_PEER_REQUESTED_CLOSE;\n            var respondCloseReasonCode;\n\n            // Make sure the close reason provided is legal according to\n            // the protocol spec.  Providing no close status is legal.\n            // WebSocketFrame sets closeStatus to -1 by default, so if it\n            // is still -1, then no status was provided.\n            if (frame.invalidCloseFrameLength) {\n                this.closeReasonCode = 1005; // 1005 = No reason provided.\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            else if (frame.closeStatus === -1 || validateCloseReason(frame.closeStatus)) {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n            }\n            else {\n                this.closeReasonCode = frame.closeStatus;\n                respondCloseReasonCode = WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR;\n            }\n            \n            // If there is a textual description in the close frame, extract it.\n            if (frame.binaryPayload.length > 1) {\n                if (!Validation.isValidUTF8(frame.binaryPayload)) {\n                    this.drop(WebSocketConnection.CLOSE_REASON_INVALID_DATA,\n                      'Invalid UTF-8 Data Received');\n                    return;\n                }\n                this.closeDescription = frame.binaryPayload.toString('utf8');\n            }\n            else {\n                this.closeDescription = WebSocketConnection.CLOSE_DESCRIPTIONS[this.closeReasonCode];\n            }\n            this._debug(\n                '------ Remote peer %s - code: %d - %s - close frame payload length: %d',\n                this.remoteAddress, this.closeReasonCode,\n                this.closeDescription, frame.length\n            );\n            this._debug('------ responding to remote peer\\'s close request.');\n            this.sendCloseFrame(respondCloseReasonCode, null);\n            this.connected = false;\n            break;\n        default:\n            this._debug('-- Unrecognized Opcode %d', frame.opcode);\n            this.drop(WebSocketConnection.CLOSE_REASON_PROTOCOL_ERROR,\n              'Unrecognized Opcode: 0x' + frame.opcode.toString(16));\n            break;\n    }\n};\n\nWebSocketConnection.prototype.send = function(data, cb) {\n    this._debug('send');\n    if (Buffer.isBuffer(data)) {\n        this.sendBytes(data, cb);\n    }\n    else if (typeof(data['toString']) === 'function') {\n        this.sendUTF(data, cb);\n    }\n    else {\n        throw new Error('Data provided must either be a Node Buffer or implement toString()');\n    }\n};\n\nWebSocketConnection.prototype.sendUTF = function(data, cb) {\n    data = bufferFromString(data.toString(), 'utf8');\n    this._debug('sendUTF: %d bytes', data.length);\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x01; // WebSocketOpcode.TEXT_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.sendBytes = function(data, cb) {\n    this._debug('sendBytes');\n    if (!Buffer.isBuffer(data)) {\n        throw new Error('You must pass a Node Buffer object to WebSocketConnection.prototype.sendBytes()');\n    }\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x02; // WebSocketOpcode.BINARY_FRAME\n    frame.binaryPayload = data;\n    this.fragmentAndSend(frame, cb);\n};\n\nWebSocketConnection.prototype.ping = function(data) {\n    this._debug('ping');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x09; // WebSocketOpcode.PING\n    frame.fin = true;\n    if (data) {\n        if (!Buffer.isBuffer(data)) {\n            data = bufferFromString(data.toString(), 'utf8');\n        }\n        if (data.length > 125) {\n            this._debug('WebSocket: Data for ping is longer than 125 bytes.  Truncating.');\n            data = data.slice(0,124);\n        }\n        frame.binaryPayload = data;\n    }\n    this.sendFrame(frame);\n};\n\n// Pong frames have to echo back the contents of the data portion of the\n// ping frame exactly, byte for byte.\nWebSocketConnection.prototype.pong = function(binaryPayload) {\n    this._debug('pong');\n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.opcode = 0x0A; // WebSocketOpcode.PONG\n    if (Buffer.isBuffer(binaryPayload) && binaryPayload.length > 125) {\n        this._debug('WebSocket: Data for pong is longer than 125 bytes.  Truncating.');\n        binaryPayload = binaryPayload.slice(0,124);\n    }\n    frame.binaryPayload = binaryPayload;\n    frame.fin = true;\n    this.sendFrame(frame);\n};\n\nWebSocketConnection.prototype.fragmentAndSend = function(frame, cb) {\n    this._debug('fragmentAndSend');\n    if (frame.opcode > 0x07) {\n        throw new Error('You cannot fragment control frames.');\n    }\n\n    var threshold = this.config.fragmentationThreshold;\n    var length = frame.binaryPayload.length;\n\n    // Send immediately if fragmentation is disabled or the message is not\n    // larger than the fragmentation threshold.\n    if (!this.config.fragmentOutgoingMessages || (frame.binaryPayload && length <= threshold)) {\n        frame.fin = true;\n        this.sendFrame(frame, cb);\n        return;\n    }\n    \n    var numFragments = Math.ceil(length / threshold);\n    var sentFragments = 0;\n    var sentCallback = function fragmentSentCallback(err) {\n        if (err) {\n            if (typeof cb === 'function') {\n                // pass only the first error\n                cb(err);\n                cb = null;\n            }\n            return;\n        }\n        ++sentFragments;\n        if ((sentFragments === numFragments) && (typeof cb === 'function')) {\n            cb();\n        }\n    };\n    for (var i=1; i <= numFragments; i++) {\n        var currentFrame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n        \n        // continuation opcode except for first frame.\n        currentFrame.opcode = (i === 1) ? frame.opcode : 0x00;\n        \n        // fin set on last frame only\n        currentFrame.fin = (i === numFragments);\n        \n        // length is likely to be shorter on the last fragment\n        var currentLength = (i === numFragments) ? length - (threshold * (i-1)) : threshold;\n        var sliceStart = threshold * (i-1);\n        \n        // Slice the right portion of the original payload\n        currentFrame.binaryPayload = frame.binaryPayload.slice(sliceStart, sliceStart + currentLength);\n        \n        this.sendFrame(currentFrame, sentCallback);\n    }\n};\n\nWebSocketConnection.prototype.sendCloseFrame = function(reasonCode, description, cb) {\n    if (typeof(reasonCode) !== 'number') {\n        reasonCode = WebSocketConnection.CLOSE_REASON_NORMAL;\n    }\n    \n    this._debug('sendCloseFrame state: %s, reasonCode: %d, description: %s', this.state, reasonCode, description);\n    \n    if (this.state !== STATE_OPEN && this.state !== STATE_PEER_REQUESTED_CLOSE) { return; }\n    \n    var frame = new WebSocketFrame(this.maskBytes, this.frameHeader, this.config);\n    frame.fin = true;\n    frame.opcode = 0x08; // WebSocketOpcode.CONNECTION_CLOSE\n    frame.closeStatus = reasonCode;\n    if (typeof(description) === 'string') {\n        frame.binaryPayload = bufferFromString(description, 'utf8');\n    }\n    \n    this.sendFrame(frame, cb);\n    this.socket.end();\n};\n\nWebSocketConnection.prototype.sendFrame = function(frame, cb) {\n    this._debug('sendFrame');\n    frame.mask = this.maskOutgoingPackets;\n    var flushed = this.socket.write(frame.toBuffer(), cb);\n    this.outputBufferFull = !flushed;\n    return flushed;\n};\n\nmodule.exports = WebSocketConnection;\n\n\n\nfunction instrumentSocketForDebugging(connection, socket) {\n    /* jshint loopfunc: true */\n    if (!connection._debug.enabled) { return; }\n    \n    var originalSocketEmit = socket.emit;\n    socket.emit = function(event) {\n        connection._debug('||| Socket Event  \\'%s\\'', event);\n        originalSocketEmit.apply(this, arguments);\n    };\n    \n    for (var key in socket) {\n        if ('function' !== typeof(socket[key])) { continue; }\n        if (['emit'].indexOf(key) !== -1) { continue; }\n        (function(key) {\n            var original = socket[key];\n            if (key === 'on') {\n                socket[key] = function proxyMethod__EventEmitter__On() {\n                    connection._debug('||| Socket method called:  %s (%s)', key, arguments[0]);\n                    return original.apply(this, arguments);\n                };\n                return;\n            }\n            socket[key] = function proxyMethod() {\n                connection._debug('||| Socket method called:  %s', key);\n                return original.apply(this, arguments);\n            };\n        })(key);\n    }\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketConnection.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketFrame.js":
/*!******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketFrame.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar bufferUtil = __webpack_require__(/*! ./BufferUtil */ \"./node_modules/websocket/lib/BufferUtil.js\").BufferUtil;\nvar bufferAllocUnsafe = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe;\n\nconst DECODE_HEADER = 1;\nconst WAITING_FOR_16_BIT_LENGTH = 2;\nconst WAITING_FOR_64_BIT_LENGTH = 3;\nconst WAITING_FOR_MASK_KEY = 4;\nconst WAITING_FOR_PAYLOAD = 5;\nconst COMPLETE = 6;\n\n// WebSocketConnection will pass shared buffer objects for maskBytes and\n// frameHeader into the constructor to avoid tons of small memory allocations\n// for each frame we have to parse.  This is only used for parsing frames\n// we receive off the wire.\nfunction WebSocketFrame(maskBytes, frameHeader, config) {\n    this.maskBytes = maskBytes;\n    this.frameHeader = frameHeader;\n    this.config = config;\n    this.maxReceivedFrameSize = config.maxReceivedFrameSize;\n    this.protocolError = false;\n    this.frameTooLarge = false;\n    this.invalidCloseFrameLength = false;\n    this.parseState = DECODE_HEADER;\n    this.closeStatus = -1;\n}\n\nWebSocketFrame.prototype.addData = function(bufferList) {\n    if (this.parseState === DECODE_HEADER) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 0, 0, 2);\n            bufferList.advance(2);\n            var firstByte = this.frameHeader[0];\n            var secondByte = this.frameHeader[1];\n\n            this.fin     = Boolean(firstByte  & 0x80);\n            this.rsv1    = Boolean(firstByte  & 0x40);\n            this.rsv2    = Boolean(firstByte  & 0x20);\n            this.rsv3    = Boolean(firstByte  & 0x10);\n            this.mask    = Boolean(secondByte & 0x80);\n\n            this.opcode  = firstByte  & 0x0F;\n            this.length = secondByte & 0x7F;\n\n            // Control frame sanity check\n            if (this.opcode >= 0x08) {\n                if (this.length > 125) {\n                    this.protocolError = true;\n                    this.dropReason = 'Illegal control frame longer than 125 bytes.';\n                    return true;\n                }\n                if (!this.fin) {\n                    this.protocolError = true;\n                    this.dropReason = 'Control frames must not be fragmented.';\n                    return true;\n                }\n            }\n\n            if (this.length === 126) {\n                this.parseState = WAITING_FOR_16_BIT_LENGTH;\n            }\n            else if (this.length === 127) {\n                this.parseState = WAITING_FOR_64_BIT_LENGTH;\n            }\n            else {\n                this.parseState = WAITING_FOR_MASK_KEY;\n            }\n        }\n    }\n    if (this.parseState === WAITING_FOR_16_BIT_LENGTH) {\n        if (bufferList.length >= 2) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 2);\n            bufferList.advance(2);\n            this.length = this.frameHeader.readUInt16BE(2);\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n    else if (this.parseState === WAITING_FOR_64_BIT_LENGTH) {\n        if (bufferList.length >= 8) {\n            bufferList.joinInto(this.frameHeader, 2, 0, 8);\n            bufferList.advance(8);\n            var lengthPair = [\n              this.frameHeader.readUInt32BE(2),\n              this.frameHeader.readUInt32BE(2+4)\n            ];\n\n            if (lengthPair[0] !== 0) {\n                this.protocolError = true;\n                this.dropReason = 'Unsupported 64-bit length frame received';\n                return true;\n            }\n            this.length = lengthPair[1];\n            this.parseState = WAITING_FOR_MASK_KEY;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_MASK_KEY) {\n        if (this.mask) {\n            if (bufferList.length >= 4) {\n                bufferList.joinInto(this.maskBytes, 0, 0, 4);\n                bufferList.advance(4);\n                this.parseState = WAITING_FOR_PAYLOAD;\n            }\n        }\n        else {\n            this.parseState = WAITING_FOR_PAYLOAD;\n        }\n    }\n\n    if (this.parseState === WAITING_FOR_PAYLOAD) {\n        if (this.length > this.maxReceivedFrameSize) {\n            this.frameTooLarge = true;\n            this.dropReason = 'Frame size of ' + this.length.toString(10) +\n                              ' bytes exceeds maximum accepted frame size';\n            return true;\n        }\n\n        if (this.length === 0) {\n            this.binaryPayload = bufferAllocUnsafe(0);\n            this.parseState = COMPLETE;\n            return true;\n        }\n        if (bufferList.length >= this.length) {\n            this.binaryPayload = bufferList.take(this.length);\n            bufferList.advance(this.length);\n            if (this.mask) {\n                bufferUtil.unmask(this.binaryPayload, this.maskBytes);\n                // xor(this.binaryPayload, this.maskBytes, 0);\n            }\n\n            if (this.opcode === 0x08) { // WebSocketOpcode.CONNECTION_CLOSE\n                if (this.length === 1) {\n                    // Invalid length for a close frame.  Must be zero or at least two.\n                    this.binaryPayload = bufferAllocUnsafe(0);\n                    this.invalidCloseFrameLength = true;\n                }\n                if (this.length >= 2) {\n                    this.closeStatus = this.binaryPayload.readUInt16BE(0);\n                    this.binaryPayload = this.binaryPayload.slice(2);\n                }\n            }\n\n            this.parseState = COMPLETE;\n            return true;\n        }\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.throwAwayPayload = function(bufferList) {\n    if (bufferList.length >= this.length) {\n        bufferList.advance(this.length);\n        this.parseState = COMPLETE;\n        return true;\n    }\n    return false;\n};\n\nWebSocketFrame.prototype.toBuffer = function(nullMask) {\n    var maskKey;\n    var headerLength = 2;\n    var data;\n    var outputPos;\n    var firstByte = 0x00;\n    var secondByte = 0x00;\n\n    if (this.fin) {\n        firstByte |= 0x80;\n    }\n    if (this.rsv1) {\n        firstByte |= 0x40;\n    }\n    if (this.rsv2) {\n        firstByte |= 0x20;\n    }\n    if (this.rsv3) {\n        firstByte |= 0x10;\n    }\n    if (this.mask) {\n        secondByte |= 0x80;\n    }\n\n    firstByte |= (this.opcode & 0x0F);\n\n    // the close frame is a special case because the close reason is\n    // prepended to the payload data.\n    if (this.opcode === 0x08) {\n        this.length = 2;\n        if (this.binaryPayload) {\n            this.length += this.binaryPayload.length;\n        }\n        data = bufferAllocUnsafe(this.length);\n        data.writeUInt16BE(this.closeStatus, 0);\n        if (this.length > 2) {\n            this.binaryPayload.copy(data, 2);\n        }\n    }\n    else if (this.binaryPayload) {\n        data = this.binaryPayload;\n        this.length = data.length;\n    }\n    else {\n        this.length = 0;\n    }\n\n    if (this.length <= 125) {\n        // encode the length directly into the two-byte frame header\n        secondByte |= (this.length & 0x7F);\n    }\n    else if (this.length > 125 && this.length <= 0xFFFF) {\n        // Use 16-bit length\n        secondByte |= 126;\n        headerLength += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // Use 64-bit length\n        secondByte |= 127;\n        headerLength += 8;\n    }\n\n    var output = bufferAllocUnsafe(this.length + headerLength + (this.mask ? 4 : 0));\n\n    // write the frame header\n    output[0] = firstByte;\n    output[1] = secondByte;\n\n    outputPos = 2;\n\n    if (this.length > 125 && this.length <= 0xFFFF) {\n        // write 16-bit length\n        output.writeUInt16BE(this.length, outputPos);\n        outputPos += 2;\n    }\n    else if (this.length > 0xFFFF) {\n        // write 64-bit length\n        output.writeUInt32BE(0x00000000, outputPos);\n        output.writeUInt32BE(this.length, outputPos + 4);\n        outputPos += 8;\n    }\n\n    if (this.mask) {\n        maskKey = nullMask ? 0 : ((Math.random() * 0xFFFFFFFF) >>> 0);\n        this.maskBytes.writeUInt32BE(maskKey, 0);\n\n        // write the mask key\n        this.maskBytes.copy(output, outputPos);\n        outputPos += 4;\n\n        if (data) {\n          bufferUtil.mask(data, this.maskBytes, output, outputPos, this.length);\n        }\n    }\n    else if (data) {\n        data.copy(output, outputPos);\n    }\n\n    return output;\n};\n\nWebSocketFrame.prototype.toString = function() {\n    return 'Opcode: ' + this.opcode + ', fin: ' + this.fin + ', length: ' + this.length + ', hasPayload: ' + Boolean(this.binaryPayload) + ', masked: ' + this.mask;\n};\n\n\nmodule.exports = WebSocketFrame;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketFrame.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRequest.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar crypto = __webpack_require__(/*! crypto */ \"crypto\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar url = __webpack_require__(/*! url */ \"url\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar WebSocketConnection = __webpack_require__(/*! ./WebSocketConnection */ \"./node_modules/websocket/lib/WebSocketConnection.js\");\n\nvar headerValueSplitRegExp = /,\\s*/;\nvar headerParamSplitRegExp = /;\\s*/;\nvar headerSanitizeRegExp = /[\\r\\n]/g;\nvar xForwardedForSeparatorRegExp = /,\\s*/;\nvar separators = [\n    '(', ')', '<', '>', '@',\n    ',', ';', ':', '\\\\', '\\\"',\n    '/', '[', ']', '?', '=',\n    '{', '}', ' ', String.fromCharCode(9)\n];\nvar controlChars = [String.fromCharCode(127) /* DEL */];\nfor (var i=0; i < 31; i ++) {\n    /* US-ASCII Control Characters */\n    controlChars.push(String.fromCharCode(i));\n}\n\nvar cookieNameValidateRegEx = /([\\x00-\\x20\\x22\\x28\\x29\\x2c\\x2f\\x3a-\\x3f\\x40\\x5b-\\x5e\\x7b\\x7d\\x7f])/;\nvar cookieValueValidateRegEx = /[^\\x21\\x23-\\x2b\\x2d-\\x3a\\x3c-\\x5b\\x5d-\\x7e]/;\nvar cookieValueDQuoteValidateRegEx = /^\"[^\"]*\"$/;\nvar controlCharsAndSemicolonRegEx = /[\\x00-\\x20\\x3b]/g;\n\nvar cookieSeparatorRegEx = /[;,] */;\n\nvar httpStatusDescriptions = {\n    100: 'Continue',\n    101: 'Switching Protocols',\n    200: 'OK',\n    201: 'Created',\n    203: 'Non-Authoritative Information',\n    204: 'No Content',\n    205: 'Reset Content',\n    206: 'Partial Content',\n    300: 'Multiple Choices',\n    301: 'Moved Permanently',\n    302: 'Found',\n    303: 'See Other',\n    304: 'Not Modified',\n    305: 'Use Proxy',\n    307: 'Temporary Redirect',\n    400: 'Bad Request',\n    401: 'Unauthorized',\n    402: 'Payment Required',\n    403: 'Forbidden',\n    404: 'Not Found',\n    406: 'Not Acceptable',\n    407: 'Proxy Authorization Required',\n    408: 'Request Timeout',\n    409: 'Conflict',\n    410: 'Gone',\n    411: 'Length Required',\n    412: 'Precondition Failed',\n    413: 'Request Entity Too Long',\n    414: 'Request-URI Too Long',\n    415: 'Unsupported Media Type',\n    416: 'Requested Range Not Satisfiable',\n    417: 'Expectation Failed',\n    426: 'Upgrade Required',\n    500: 'Internal Server Error',\n    501: 'Not Implemented',\n    502: 'Bad Gateway',\n    503: 'Service Unavailable',\n    504: 'Gateway Timeout',\n    505: 'HTTP Version Not Supported'\n};\n\nfunction WebSocketRequest(socket, httpRequest, serverConfig) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.socket = socket;\n    this.httpRequest = httpRequest;\n    this.resource = httpRequest.url;\n    this.remoteAddress = socket.remoteAddress;\n    this.remoteAddresses = [this.remoteAddress];\n    this.serverConfig = serverConfig;\n    \n    // Watch for the underlying TCP socket closing before we call accept\n    this._socketIsClosing = false;\n    this._socketCloseHandler = this._handleSocketCloseBeforeAccept.bind(this);\n    this.socket.on('end', this._socketCloseHandler);\n    this.socket.on('close', this._socketCloseHandler);\n    \n    this._resolved = false;\n}\n\nutil.inherits(WebSocketRequest, EventEmitter);\n\nWebSocketRequest.prototype.readHandshake = function() {\n    var self = this;\n    var request = this.httpRequest;\n\n    // Decode URL\n    this.resourceURL = url.parse(this.resource, true);\n\n    this.host = request.headers['host'];\n    if (!this.host) {\n        throw new Error('Client must provide a Host header.');\n    }\n\n    this.key = request.headers['sec-websocket-key'];\n    if (!this.key) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Key.');\n    }\n\n    this.webSocketVersion = parseInt(request.headers['sec-websocket-version'], 10);\n\n    if (!this.webSocketVersion || isNaN(this.webSocketVersion)) {\n        throw new Error('Client must provide a value for Sec-WebSocket-Version.');\n    }\n\n    switch (this.webSocketVersion) {\n        case 8:\n        case 13:\n            break;\n        default:\n            var e = new Error('Unsupported websocket client version: ' + this.webSocketVersion +\n                              'Only versions 8 and 13 are supported.');\n            e.httpCode = 426;\n            e.headers = {\n                'Sec-WebSocket-Version': '13'\n            };\n            throw e;\n    }\n\n    if (this.webSocketVersion === 13) {\n        this.origin = request.headers['origin'];\n    }\n    else if (this.webSocketVersion === 8) {\n        this.origin = request.headers['sec-websocket-origin'];\n    }\n\n    // Protocol is optional.\n    var protocolString = request.headers['sec-websocket-protocol'];\n    this.protocolFullCaseMap = {};\n    this.requestedProtocols = [];\n    if (protocolString) {\n        var requestedProtocolsFullCase = protocolString.split(headerValueSplitRegExp);\n        requestedProtocolsFullCase.forEach(function(protocol) {\n            var lcProtocol = protocol.toLocaleLowerCase();\n            self.requestedProtocols.push(lcProtocol);\n            self.protocolFullCaseMap[lcProtocol] = protocol;\n        });\n    }\n\n    if (!this.serverConfig.ignoreXForwardedFor &&\n        request.headers['x-forwarded-for']) {\n        var immediatePeerIP = this.remoteAddress;\n        this.remoteAddresses = request.headers['x-forwarded-for']\n            .split(xForwardedForSeparatorRegExp);\n        this.remoteAddresses.push(immediatePeerIP);\n        this.remoteAddress = this.remoteAddresses[0];\n    }\n\n    // Extensions are optional.\n    var extensionsString = request.headers['sec-websocket-extensions'];\n    this.requestedExtensions = this.parseExtensions(extensionsString);\n\n    // Cookies are optional\n    var cookieString = request.headers['cookie'];\n    this.cookies = this.parseCookies(cookieString);\n};\n\nWebSocketRequest.prototype.parseExtensions = function(extensionsString) {\n    if (!extensionsString || extensionsString.length === 0) {\n        return [];\n    }\n    var extensions = extensionsString.toLocaleLowerCase().split(headerValueSplitRegExp);\n    extensions.forEach(function(extension, index, array) {\n        var params = extension.split(headerParamSplitRegExp);\n        var extensionName = params[0];\n        var extensionParams = params.slice(1);\n        extensionParams.forEach(function(rawParam, index, array) {\n            var arr = rawParam.split('=');\n            var obj = {\n                name: arr[0],\n                value: arr[1]\n            };\n            array.splice(index, 1, obj);\n        });\n        var obj = {\n            name: extensionName,\n            params: extensionParams\n        };\n        array.splice(index, 1, obj);\n    });\n    return extensions;\n};\n\n// This function adapted from node-cookie\n// https://github.com/shtylman/node-cookie\nWebSocketRequest.prototype.parseCookies = function(str) {\n    // Sanity Check\n    if (!str || typeof(str) !== 'string') {\n        return [];\n    }\n\n    var cookies = [];\n    var pairs = str.split(cookieSeparatorRegEx);\n\n    pairs.forEach(function(pair) {\n        var eq_idx = pair.indexOf('=');\n        if (eq_idx === -1) {\n            cookies.push({\n                name: pair,\n                value: null\n            });\n            return;\n        }\n\n        var key = pair.substr(0, eq_idx).trim();\n        var val = pair.substr(++eq_idx, pair.length).trim();\n\n        // quoted values\n        if ('\"' === val[0]) {\n            val = val.slice(1, -1);\n        }\n\n        cookies.push({\n            name: key,\n            value: decodeURIComponent(val)\n        });\n    });\n\n    return cookies;\n};\n\nWebSocketRequest.prototype.accept = function(acceptedProtocol, allowedOrigin, cookies) {\n    this._verifyResolution();\n    \n    // TODO: Handle extensions\n\n    var protocolFullCase;\n\n    if (acceptedProtocol) {\n        protocolFullCase = this.protocolFullCaseMap[acceptedProtocol.toLocaleLowerCase()];\n        if (typeof(protocolFullCase) === 'undefined') {\n            protocolFullCase = acceptedProtocol;\n        }\n    }\n    else {\n        protocolFullCase = acceptedProtocol;\n    }\n    this.protocolFullCaseMap = null;\n\n    // Create key validation hash\n    var sha1 = crypto.createHash('sha1');\n    sha1.update(this.key + '258EAFA5-E914-47DA-95CA-C5AB0DC85B11');\n    var acceptKey = sha1.digest('base64');\n\n    var response = 'HTTP/1.1 101 Switching Protocols\\r\\n' +\n                   'Upgrade: websocket\\r\\n' +\n                   'Connection: Upgrade\\r\\n' +\n                   'Sec-WebSocket-Accept: ' + acceptKey + '\\r\\n';\n\n    if (protocolFullCase) {\n        // validate protocol\n        for (var i=0; i < protocolFullCase.length; i++) {\n            var charCode = protocolFullCase.charCodeAt(i);\n            var character = protocolFullCase.charAt(i);\n            if (charCode < 0x21 || charCode > 0x7E || separators.indexOf(character) !== -1) {\n                this.reject(500);\n                throw new Error('Illegal character \"' + String.fromCharCode(character) + '\" in subprotocol.');\n            }\n        }\n        if (this.requestedProtocols.indexOf(acceptedProtocol) === -1) {\n            this.reject(500);\n            throw new Error('Specified protocol was not requested by the client.');\n        }\n\n        protocolFullCase = protocolFullCase.replace(headerSanitizeRegExp, '');\n        response += 'Sec-WebSocket-Protocol: ' + protocolFullCase + '\\r\\n';\n    }\n    this.requestedProtocols = null;\n\n    if (allowedOrigin) {\n        allowedOrigin = allowedOrigin.replace(headerSanitizeRegExp, '');\n        if (this.webSocketVersion === 13) {\n            response += 'Origin: ' + allowedOrigin + '\\r\\n';\n        }\n        else if (this.webSocketVersion === 8) {\n            response += 'Sec-WebSocket-Origin: ' + allowedOrigin + '\\r\\n';\n        }\n    }\n\n    if (cookies) {\n        if (!Array.isArray(cookies)) {\n            this.reject(500);\n            throw new Error('Value supplied for \"cookies\" argument must be an array.');\n        }\n        var seenCookies = {};\n        cookies.forEach(function(cookie) {\n            if (!cookie.name || !cookie.value) {\n                this.reject(500);\n                throw new Error('Each cookie to set must at least provide a \"name\" and \"value\"');\n            }\n\n            // Make sure there are no \\r\\n sequences inserted\n            cookie.name = cookie.name.replace(controlCharsAndSemicolonRegEx, '');\n            cookie.value = cookie.value.replace(controlCharsAndSemicolonRegEx, '');\n\n            if (seenCookies[cookie.name]) {\n                this.reject(500);\n                throw new Error('You may not specify the same cookie name twice.');\n            }\n            seenCookies[cookie.name] = true;\n\n            // token (RFC 2616, Section 2.2)\n            var invalidChar = cookie.name.match(cookieNameValidateRegEx);\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie name');\n            }\n\n            // RFC 6265, Section 4.1.1\n            // *cookie-octet / ( DQUOTE *cookie-octet DQUOTE ) | %x21 / %x23-2B / %x2D-3A / %x3C-5B / %x5D-7E\n            if (cookie.value.match(cookieValueDQuoteValidateRegEx)) {\n                invalidChar = cookie.value.slice(1, -1).match(cookieValueValidateRegEx);\n            } else {\n                invalidChar = cookie.value.match(cookieValueValidateRegEx);\n            }\n            if (invalidChar) {\n                this.reject(500);\n                throw new Error('Illegal character ' + invalidChar[0] + ' in cookie value');\n            }\n\n            var cookieParts = [cookie.name + '=' + cookie.value];\n\n            // RFC 6265, Section 4.1.1\n            // 'Path=' path-value | <any CHAR except CTLs or ';'>\n            if(cookie.path){\n                invalidChar = cookie.path.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie path');\n                }\n                cookieParts.push('Path=' + cookie.path);\n            }\n\n            // RFC 6265, Section 4.1.2.3\n            // 'Domain=' subdomain\n            if (cookie.domain) {\n                if (typeof(cookie.domain) !== 'string') {\n                    this.reject(500);\n                    throw new Error('Domain must be specified and must be a string.');\n                }\n                invalidChar = cookie.domain.match(controlCharsAndSemicolonRegEx);\n                if (invalidChar) {\n                    this.reject(500);\n                    throw new Error('Illegal character ' + invalidChar[0] + ' in cookie domain');\n                }\n                cookieParts.push('Domain=' + cookie.domain.toLowerCase());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Expires=' sane-cookie-date | Force Date object requirement by using only epoch\n            if (cookie.expires) {\n                if (!(cookie.expires instanceof Date)){\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"expires\" must be a vaild date object');\n                }\n                cookieParts.push('Expires=' + cookie.expires.toGMTString());\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Max-Age=' non-zero-digit *DIGIT\n            if (cookie.maxage) {\n                var maxage = cookie.maxage;\n                if (typeof(maxage) === 'string') {\n                    maxage = parseInt(maxage, 10);\n                }\n                if (isNaN(maxage) || maxage <= 0 ) {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"maxage\" must be a non-zero number');\n                }\n                maxage = Math.round(maxage);\n                cookieParts.push('Max-Age=' + maxage.toString(10));\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'Secure;'\n            if (cookie.secure) {\n                if (typeof(cookie.secure) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"secure\" must be of type boolean');\n                }\n                cookieParts.push('Secure');\n            }\n\n            // RFC 6265, Section 4.1.1\n            //'HttpOnly;'\n            if (cookie.httponly) {\n                if (typeof(cookie.httponly) !== 'boolean') {\n                    this.reject(500);\n                    throw new Error('Value supplied for cookie \"httponly\" must be of type boolean');\n                }\n                cookieParts.push('HttpOnly');\n            }\n\n            response += ('Set-Cookie: ' + cookieParts.join(';') + '\\r\\n');\n        }.bind(this));\n    }\n\n    // TODO: handle negotiated extensions\n    // if (negotiatedExtensions) {\n    //     response += 'Sec-WebSocket-Extensions: ' + negotiatedExtensions.join(', ') + '\\r\\n';\n    // }\n    \n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n    \n    response += '\\r\\n';\n\n    var connection = new WebSocketConnection(this.socket, [], acceptedProtocol, false, this.serverConfig);\n    connection.webSocketVersion = this.webSocketVersion;\n    connection.remoteAddress = this.remoteAddress;\n    connection.remoteAddresses = this.remoteAddresses;\n    \n    var self = this;\n    \n    if (this._socketIsClosing) {\n        // Handle case when the client hangs up before we get a chance to\n        // accept the connection and send our side of the opening handshake.\n        cleanupFailedConnection(connection);\n    }\n    else {\n        this.socket.write(response, 'ascii', function(error) {\n            if (error) {\n                cleanupFailedConnection(connection);\n                return;\n            }\n            \n            self._removeSocketCloseListeners();\n            connection._addSocketEventListeners();\n        });\n    }\n\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this._verifyResolution();\n    \n    // Mark the request resolved now so that the user can't call accept or\n    // reject a second time.\n    this._resolved = true;\n    this.emit('requestResolved', this);\n    \n    if (typeof(status) !== 'number') {\n        status = 403;\n    }\n    var response = 'HTTP/1.1 ' + status + ' ' + httpStatusDescriptions[status] + '\\r\\n' +\n                   'Connection: close\\r\\n';\n    if (reason) {\n        reason = reason.replace(headerSanitizeRegExp, '');\n        response += 'X-WebSocket-Reject-Reason: ' + reason + '\\r\\n';\n    }\n\n    if (extraHeaders) {\n        for (var key in extraHeaders) {\n            var sanitizedValue = extraHeaders[key].toString().replace(headerSanitizeRegExp, '');\n            var sanitizedKey = key.replace(headerSanitizeRegExp, '');\n            response += (sanitizedKey + ': ' + sanitizedValue + '\\r\\n');\n        }\n    }\n\n    response += '\\r\\n';\n    this.socket.end(response, 'ascii');\n\n    this.emit('requestRejected', this);\n};\n\nWebSocketRequest.prototype._handleSocketCloseBeforeAccept = function() {\n    this._socketIsClosing = true;\n    this._removeSocketCloseListeners();\n};\n\nWebSocketRequest.prototype._removeSocketCloseListeners = function() {\n    this.socket.removeListener('end', this._socketCloseHandler);\n    this.socket.removeListener('close', this._socketCloseHandler);\n};\n\nWebSocketRequest.prototype._verifyResolution = function() {\n    if (this._resolved) {\n        throw new Error('WebSocketRequest may only be accepted or rejected one time.');\n    }\n};\n\nfunction cleanupFailedConnection(connection) {\n    // Since we have to return a connection object even if the socket is\n    // already dead in order not to break the API, we schedule a 'close'\n    // event on the connection object to occur immediately.\n    process.nextTick(function() {\n        // WebSocketConnection.CLOSE_REASON_ABNORMAL = 1006\n        // Third param: Skip sending the close frame to a dead socket\n        connection.drop(1006, 'TCP connection lost before handshake completed.', true);\n    });\n}\n\nmodule.exports = WebSocketRequest;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketRequest.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketRouter.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouter.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\").extend;\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar WebSocketRouterRequest = __webpack_require__(/*! ./WebSocketRouterRequest */ \"./node_modules/websocket/lib/WebSocketRouterRequest.js\");\n\nfunction WebSocketRouter(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.config = {\n        // The WebSocketServer instance to attach to.\n        server: null\n    };\n    if (config) {\n        extend(this.config, config);\n    }\n    this.handlers = [];\n\n    this._requestHandler = this.handleRequest.bind(this);\n    if (this.config.server) {\n        this.attachServer(this.config.server);\n    }\n}\n\nutil.inherits(WebSocketRouter, EventEmitter);\n\nWebSocketRouter.prototype.attachServer = function(server) {\n    if (server) {\n        this.server = server;\n        this.server.on('request', this._requestHandler);\n    }\n    else {\n        throw new Error('You must specify a WebSocketServer instance to attach to.');\n    }\n};\n\nWebSocketRouter.prototype.detachServer = function() {\n    if (this.server) {\n        this.server.removeListener('request', this._requestHandler);\n        this.server = null;\n    }\n    else {\n        throw new Error('Cannot detach from server: not attached.');\n    }\n};\n\nWebSocketRouter.prototype.mount = function(path, protocol, callback) {\n    if (!path) {\n        throw new Error('You must specify a path for this handler.');\n    }\n    if (!protocol) {\n        protocol = '____no_protocol____';\n    }\n    if (!callback) {\n        throw new Error('You must specify a callback for this handler.');\n    }\n\n    path = this.pathToRegExp(path);\n    if (!(path instanceof RegExp)) {\n        throw new Error('Path must be specified as either a string or a RegExp.');\n    }\n    var pathString = path.toString();\n\n    // normalize protocol to lower-case\n    protocol = protocol.toLocaleLowerCase();\n\n    if (this.findHandlerIndex(pathString, protocol) !== -1) {\n        throw new Error('You may only mount one handler per path/protocol combination.');\n    }\n\n    this.handlers.push({\n        'path': path,\n        'pathString': pathString,\n        'protocol': protocol,\n        'callback': callback\n    });\n};\nWebSocketRouter.prototype.unmount = function(path, protocol) {\n    var index = this.findHandlerIndex(this.pathToRegExp(path).toString(), protocol);\n    if (index !== -1) {\n        this.handlers.splice(index, 1);\n    }\n    else {\n        throw new Error('Unable to find a route matching the specified path and protocol.');\n    }\n};\n\nWebSocketRouter.prototype.findHandlerIndex = function(pathString, protocol) {\n    protocol = protocol.toLocaleLowerCase();\n    for (var i=0, len=this.handlers.length; i < len; i++) {\n        var handler = this.handlers[i];\n        if (handler.pathString === pathString && handler.protocol === protocol) {\n            return i;\n        }\n    }\n    return -1;\n};\n\nWebSocketRouter.prototype.pathToRegExp = function(path) {\n    if (typeof(path) === 'string') {\n        if (path === '*') {\n            path = /^.*$/;\n        }\n        else {\n            path = path.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n            path = new RegExp('^' + path + '$');\n        }\n    }\n    return path;\n};\n\nWebSocketRouter.prototype.handleRequest = function(request) {\n    var requestedProtocols = request.requestedProtocols;\n    if (requestedProtocols.length === 0) {\n        requestedProtocols = ['____no_protocol____'];\n    }\n\n    // Find a handler with the first requested protocol first\n    for (var i=0; i < requestedProtocols.length; i++) {\n        var requestedProtocol = requestedProtocols[i].toLocaleLowerCase();\n\n        // find the first handler that can process this request\n        for (var j=0, len=this.handlers.length; j < len; j++) {\n            var handler = this.handlers[j];\n            if (handler.path.test(request.resourceURL.pathname)) {\n                if (requestedProtocol === handler.protocol ||\n                    handler.protocol === '*')\n                {\n                    var routerRequest = new WebSocketRouterRequest(request, requestedProtocol);\n                    handler.callback(routerRequest);\n                    return;\n                }\n            }\n        }\n    }\n\n    // If we get here we were unable to find a suitable handler.\n    request.reject(404, 'No handler is available for the given request.');\n};\n\nmodule.exports = WebSocketRouter;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketRouter.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketRouterRequest.js":
/*!**************************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketRouterRequest.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar util = __webpack_require__(/*! util */ \"util\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\n\nfunction WebSocketRouterRequest(webSocketRequest, resolvedProtocol) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this.webSocketRequest = webSocketRequest;\n    if (resolvedProtocol === '____no_protocol____') {\n        this.protocol = null;\n    }\n    else {\n        this.protocol = resolvedProtocol;\n    }\n    this.origin = webSocketRequest.origin;\n    this.resource = webSocketRequest.resource;\n    this.resourceURL = webSocketRequest.resourceURL;\n    this.httpRequest = webSocketRequest.httpRequest;\n    this.remoteAddress = webSocketRequest.remoteAddress;\n    this.webSocketVersion = webSocketRequest.webSocketVersion;\n    this.requestedExtensions = webSocketRequest.requestedExtensions;\n    this.cookies = webSocketRequest.cookies;\n}\n\nutil.inherits(WebSocketRouterRequest, EventEmitter);\n\nWebSocketRouterRequest.prototype.accept = function(origin, cookies) {\n    var connection = this.webSocketRequest.accept(this.protocol, origin, cookies);\n    this.emit('requestAccepted', connection);\n    return connection;\n};\n\nWebSocketRouterRequest.prototype.reject = function(status, reason, extraHeaders) {\n    this.webSocketRequest.reject(status, reason, extraHeaders);\n    this.emit('requestRejected', this);\n};\n\nmodule.exports = WebSocketRouterRequest;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketRouterRequest.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/WebSocketServer.js":
/*!*******************************************************!*\
  !*** ./node_modules/websocket/lib/WebSocketServer.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/************************************************************************\n *  Copyright 2010-2015 Brian McKelvey.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n ***********************************************************************/\n\nvar extend = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\").extend;\nvar utils = __webpack_require__(/*! ./utils */ \"./node_modules/websocket/lib/utils.js\");\nvar util = __webpack_require__(/*! util */ \"util\");\nvar debug = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")('websocket:server');\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar WebSocketRequest = __webpack_require__(/*! ./WebSocketRequest */ \"./node_modules/websocket/lib/WebSocketRequest.js\");\n\nvar WebSocketServer = function WebSocketServer(config) {\n    // Superclass Constructor\n    EventEmitter.call(this);\n\n    this._handlers = {\n        upgrade: this.handleUpgrade.bind(this),\n        requestAccepted: this.handleRequestAccepted.bind(this),\n        requestResolved: this.handleRequestResolved.bind(this)\n    };\n    this.connections = [];\n    this.pendingRequests = [];\n    if (config) {\n        this.mount(config);\n    }\n};\n\nutil.inherits(WebSocketServer, EventEmitter);\n\nWebSocketServer.prototype.mount = function(config) {\n    this.config = {\n        // The http server instance to attach to.  Required.\n        httpServer: null,\n\n        // 64KiB max frame size.\n        maxReceivedFrameSize: 0x10000,\n\n        // 1MiB max message size, only applicable if\n        // assembleFragments is true\n        maxReceivedMessageSize: 0x100000,\n\n        // Outgoing messages larger than fragmentationThreshold will be\n        // split into multiple fragments.\n        fragmentOutgoingMessages: true,\n\n        // Outgoing frames are fragmented if they exceed this threshold.\n        // Default is 16KiB\n        fragmentationThreshold: 0x4000,\n\n        // If true, the server will automatically send a ping to all\n        // clients every 'keepaliveInterval' milliseconds.  The timer is\n        // reset on any received data from the client.\n        keepalive: true,\n\n        // The interval to send keepalive pings to connected clients if the\n        // connection is idle.  Any received data will reset the counter.\n        keepaliveInterval: 20000,\n\n        // If true, the server will consider any connection that has not\n        // received any data within the amount of time specified by\n        // 'keepaliveGracePeriod' after a keepalive ping has been sent to\n        // be dead, and will drop the connection.\n        // Ignored if keepalive is false.\n        dropConnectionOnKeepaliveTimeout: true,\n\n        // The amount of time to wait after sending a keepalive ping before\n        // closing the connection if the connected peer does not respond.\n        // Ignored if keepalive is false.\n        keepaliveGracePeriod: 10000,\n\n        // Whether to use native TCP keep-alive instead of WebSockets ping\n        // and pong packets.  Native TCP keep-alive sends smaller packets\n        // on the wire and so uses bandwidth more efficiently.  This may\n        // be more important when talking to mobile devices.\n        // If this value is set to true, then these values will be ignored:\n        //   keepaliveGracePeriod\n        //   dropConnectionOnKeepaliveTimeout\n        useNativeKeepalive: false,\n\n        // If true, fragmented messages will be automatically assembled\n        // and the full message will be emitted via a 'message' event.\n        // If false, each frame will be emitted via a 'frame' event and\n        // the application will be responsible for aggregating multiple\n        // fragmented frames.  Single-frame messages will emit a 'message'\n        // event in addition to the 'frame' event.\n        // Most users will want to leave this set to 'true'\n        assembleFragments: true,\n\n        // If this is true, websocket connections will be accepted\n        // regardless of the path and protocol specified by the client.\n        // The protocol accepted will be the first that was requested\n        // by the client.  Clients from any origin will be accepted.\n        // This should only be used in the simplest of cases.  You should\n        // probably leave this set to 'false' and inspect the request\n        // object to make sure it's acceptable before accepting it.\n        autoAcceptConnections: false,\n\n        // Whether or not the X-Forwarded-For header should be respected.\n        // It's important to set this to 'true' when accepting connections\n        // from untrusted clients, as a malicious client could spoof its\n        // IP address by simply setting this header.  It's meant to be added\n        // by a trusted proxy or other intermediary within your own\n        // infrastructure.\n        // See:  http://en.wikipedia.org/wiki/X-Forwarded-For\n        ignoreXForwardedFor: false,\n\n        // The Nagle Algorithm makes more efficient use of network resources\n        // by introducing a small delay before sending small packets so that\n        // multiple messages can be batched together before going onto the\n        // wire.  This however comes at the cost of latency, so the default\n        // is to disable it.  If you don't need low latency and are streaming\n        // lots of small messages, you can change this to 'false'\n        disableNagleAlgorithm: true,\n\n        // The number of milliseconds to wait after sending a close frame\n        // for an acknowledgement to come back before giving up and just\n        // closing the socket.\n        closeTimeout: 5000\n    };\n    extend(this.config, config);\n\n    if (this.config.httpServer) {\n        if (!Array.isArray(this.config.httpServer)) {\n            this.config.httpServer = [this.config.httpServer];\n        }\n        var upgradeHandler = this._handlers.upgrade;\n        this.config.httpServer.forEach(function(httpServer) {\n            httpServer.on('upgrade', upgradeHandler);\n        });\n    }\n    else {\n        throw new Error('You must specify an httpServer on which to mount the WebSocket server.');\n    }\n};\n\nWebSocketServer.prototype.unmount = function() {\n    var upgradeHandler = this._handlers.upgrade;\n    this.config.httpServer.forEach(function(httpServer) {\n        httpServer.removeListener('upgrade', upgradeHandler);\n    });\n};\n\nWebSocketServer.prototype.closeAllConnections = function() {\n    this.connections.forEach(function(connection) {\n        connection.close();\n    });\n    this.pendingRequests.forEach(function(request) {\n        process.nextTick(function() {\n          request.reject(503); // HTTP 503 Service Unavailable\n        });\n    });\n};\n\nWebSocketServer.prototype.broadcast = function(data) {\n    if (Buffer.isBuffer(data)) {\n        this.broadcastBytes(data);\n    }\n    else if (typeof(data.toString) === 'function') {\n        this.broadcastUTF(data);\n    }\n};\n\nWebSocketServer.prototype.broadcastUTF = function(utfData) {\n    this.connections.forEach(function(connection) {\n        connection.sendUTF(utfData);\n    });\n};\n\nWebSocketServer.prototype.broadcastBytes = function(binaryData) {\n    this.connections.forEach(function(connection) {\n        connection.sendBytes(binaryData);\n    });\n};\n\nWebSocketServer.prototype.shutDown = function() {\n    this.unmount();\n    this.closeAllConnections();\n};\n\nWebSocketServer.prototype.handleUpgrade = function(request, socket) {\n    var wsRequest = new WebSocketRequest(socket, request, this.config);\n    try {\n        wsRequest.readHandshake();\n    }\n    catch(e) {\n        wsRequest.reject(\n            e.httpCode ? e.httpCode : 400,\n            e.message,\n            e.headers\n        );\n        debug('Invalid handshake: %s', e.message);\n        return;\n    }\n    \n    this.pendingRequests.push(wsRequest);\n\n    wsRequest.once('requestAccepted', this._handlers.requestAccepted);\n    wsRequest.once('requestResolved', this._handlers.requestResolved);\n\n    if (!this.config.autoAcceptConnections && utils.eventEmitterListenerCount(this, 'request') > 0) {\n        this.emit('request', wsRequest);\n    }\n    else if (this.config.autoAcceptConnections) {\n        wsRequest.accept(wsRequest.requestedProtocols[0], wsRequest.origin);\n    }\n    else {\n        wsRequest.reject(404, 'No handler is configured to accept the connection.');\n    }\n};\n\nWebSocketServer.prototype.handleRequestAccepted = function(connection) {\n    var self = this;\n    connection.once('close', function(closeReason, description) {\n        self.handleConnectionClose(connection, closeReason, description);\n    });\n    this.connections.push(connection);\n    this.emit('connect', connection);\n};\n\nWebSocketServer.prototype.handleConnectionClose = function(connection, closeReason, description) {\n    var index = this.connections.indexOf(connection);\n    if (index !== -1) {\n        this.connections.splice(index, 1);\n    }\n    this.emit('close', connection, closeReason, description);\n};\n\nWebSocketServer.prototype.handleRequestResolved = function(request) {\n    var index = this.pendingRequests.indexOf(request);\n    if (index !== -1) { this.pendingRequests.splice(index, 1); }\n};\n\nmodule.exports = WebSocketServer;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/WebSocketServer.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/utils.js":
/*!*********************************************!*\
  !*** ./node_modules/websocket/lib/utils.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var noop = exports.noop = function(){};\n\nexports.extend = function extend(dest, source) {\n    for (var prop in source) {\n        dest[prop] = source[prop];\n    }\n};\n\nexports.eventEmitterListenerCount =\n    __webpack_require__(/*! events */ \"events\").EventEmitter.listenerCount ||\n    function(emitter, type) { return emitter.listeners(type).length; };\n\nexports.bufferAllocUnsafe = Buffer.allocUnsafe ?\n    Buffer.allocUnsafe :\n    function oldBufferAllocUnsafe(size) { return new Buffer(size); };\n\nexports.bufferFromString = Buffer.from ?\n    Buffer.from :\n    function oldBufferFromString(string, encoding) {\n      return new Buffer(string, encoding);\n    };\n\nexports.BufferingLogger = function createBufferingLogger(identifier, uniqueID) {\n    var logFunction = __webpack_require__(/*! debug */ \"./node_modules/debug/src/index.js\")(identifier);\n    if (logFunction.enabled) {\n        var logger = new BufferingLogger(identifier, uniqueID, logFunction);\n        var debug = logger.log.bind(logger);\n        debug.printOutput = logger.printOutput.bind(logger);\n        debug.enabled = logFunction.enabled;\n        return debug;\n    }\n    logFunction.printOutput = noop;\n    return logFunction;\n};\n\nfunction BufferingLogger(identifier, uniqueID, logFunction) {\n    this.logFunction = logFunction;\n    this.identifier = identifier;\n    this.uniqueID = uniqueID;\n    this.buffer = [];\n}\n\nBufferingLogger.prototype.log = function() {\n  this.buffer.push([ new Date(), Array.prototype.slice.call(arguments) ]);\n  return this;\n};\n\nBufferingLogger.prototype.clear = function() {\n  this.buffer = [];\n  return this;\n};\n\nBufferingLogger.prototype.printOutput = function(logFunction) {\n    if (!logFunction) { logFunction = this.logFunction; }\n    var uniqueID = this.uniqueID;\n    this.buffer.forEach(function(entry) {\n        var date = entry[0].toLocaleString();\n        var args = entry[1].slice();\n        var formatString = args[0];\n        if (formatString !== (void 0) && formatString !== null) {\n            formatString = '%s - %s - ' + formatString.toString();\n            args.splice(0, 1, formatString, date, uniqueID);\n            logFunction.apply(global, args);\n        }\n    });\n};\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/utils.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/version.js":
/*!***********************************************!*\
  !*** ./node_modules/websocket/lib/version.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__(/*! ../package.json */ \"./node_modules/websocket/package.json\").version;\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/version.js?");

/***/ }),

/***/ "./node_modules/websocket/lib/websocket.js":
/*!*************************************************!*\
  !*** ./node_modules/websocket/lib/websocket.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n    'server'       : __webpack_require__(/*! ./WebSocketServer */ \"./node_modules/websocket/lib/WebSocketServer.js\"),\n    'client'       : __webpack_require__(/*! ./WebSocketClient */ \"./node_modules/websocket/lib/WebSocketClient.js\"),\n    'router'       : __webpack_require__(/*! ./WebSocketRouter */ \"./node_modules/websocket/lib/WebSocketRouter.js\"),\n    'frame'        : __webpack_require__(/*! ./WebSocketFrame */ \"./node_modules/websocket/lib/WebSocketFrame.js\"),\n    'request'      : __webpack_require__(/*! ./WebSocketRequest */ \"./node_modules/websocket/lib/WebSocketRequest.js\"),\n    'connection'   : __webpack_require__(/*! ./WebSocketConnection */ \"./node_modules/websocket/lib/WebSocketConnection.js\"),\n    'w3cwebsocket' : __webpack_require__(/*! ./W3CWebSocket */ \"./node_modules/websocket/lib/W3CWebSocket.js\"),\n    'deprecation'  : __webpack_require__(/*! ./Deprecation */ \"./node_modules/websocket/lib/Deprecation.js\"),\n    'version'      : __webpack_require__(/*! ./version */ \"./node_modules/websocket/lib/version.js\")\n};\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/lib/websocket.js?");

/***/ }),

/***/ "./node_modules/websocket/package.json":
/*!*********************************************!*\
  !*** ./node_modules/websocket/package.json ***!
  \*********************************************/
/*! exports provided: _from, _id, _inBundle, _integrity, _location, _phantomChildren, _requested, _requiredBy, _resolved, _shasum, _spec, _where, author, browser, bugs, bundleDependencies, config, contributors, dependencies, deprecated, description, devDependencies, directories, engines, homepage, keywords, license, main, name, repository, scripts, version, default */
/***/ (function(module) {

eval("module.exports = {\"_from\":\"websocket@latest\",\"_id\":\"websocket@1.0.28\",\"_inBundle\":false,\"_integrity\":\"sha512-00y/20/80P7H4bCYkzuuvvfDvh+dgtXi5kzDf3UcZwN6boTYaKvsrtZ5lIYm1Gsg48siMErd9M4zjSYfYFHTrA==\",\"_location\":\"/websocket\",\"_phantomChildren\":{},\"_requested\":{\"type\":\"tag\",\"registry\":true,\"raw\":\"websocket@latest\",\"name\":\"websocket\",\"escapedName\":\"websocket\",\"rawSpec\":\"latest\",\"saveSpec\":null,\"fetchSpec\":\"latest\"},\"_requiredBy\":[\"/\"],\"_resolved\":\"https://registry.npmjs.org/websocket/-/websocket-1.0.28.tgz\",\"_shasum\":\"9e5f6fdc8a3fe01d4422647ef93abdd8d45a78d3\",\"_spec\":\"websocket@latest\",\"_where\":\"/Users/aaguilar/repos/ws-nats\",\"author\":{\"name\":\"Brian McKelvey\",\"email\":\"theturtle32@gmail.com\",\"url\":\"https://github.com/theturtle32\"},\"browser\":\"lib/browser.js\",\"bugs\":{\"url\":\"https://github.com/theturtle32/WebSocket-Node/issues\"},\"bundleDependencies\":false,\"config\":{\"verbose\":false},\"contributors\":[{\"name\":\"Iñaki Baz Castillo\",\"email\":\"ibc@aliax.net\",\"url\":\"http://dev.sipdoc.net\"}],\"dependencies\":{\"debug\":\"^2.2.0\",\"nan\":\"^2.11.0\",\"typedarray-to-buffer\":\"^3.1.5\",\"yaeti\":\"^0.0.6\"},\"deprecated\":false,\"description\":\"Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.\",\"devDependencies\":{\"buffer-equal\":\"^1.0.0\",\"faucet\":\"^0.0.1\",\"gulp\":\"git+https://github.com/gulpjs/gulp.git#4.0\",\"gulp-jshint\":\"^2.0.4\",\"jshint\":\"^2.0.0\",\"jshint-stylish\":\"^2.2.1\",\"tape\":\"^4.9.1\"},\"directories\":{\"lib\":\"./lib\"},\"engines\":{\"node\":\">=0.10.0\"},\"homepage\":\"https://github.com/theturtle32/WebSocket-Node\",\"keywords\":[\"websocket\",\"websockets\",\"socket\",\"networking\",\"comet\",\"push\",\"RFC-6455\",\"realtime\",\"server\",\"client\"],\"license\":\"Apache-2.0\",\"main\":\"index\",\"name\":\"websocket\",\"repository\":{\"type\":\"git\",\"url\":\"git+https://github.com/theturtle32/WebSocket-Node.git\"},\"scripts\":{\"gulp\":\"gulp\",\"install\":\"(node-gyp rebuild 2> builderror.log) || (exit 0)\",\"test\":\"faucet test/unit\"},\"version\":\"1.0.28\"};\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/package.json?");

/***/ }),

/***/ "./node_modules/websocket/vendor/FastBufferList.js":
/*!*********************************************************!*\
  !*** ./node_modules/websocket/vendor/FastBufferList.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("// This file was copied from https://github.com/substack/node-bufferlist\n// and modified to be able to copy bytes from the bufferlist directly into\n// a pre-existing fixed-size buffer without an additional memory allocation.\n\n// bufferlist.js\n// Treat a linked list of buffers as a single variable-size buffer.\nvar Buffer = __webpack_require__(/*! buffer */ \"buffer\").Buffer;\nvar EventEmitter = __webpack_require__(/*! events */ \"events\").EventEmitter;\nvar bufferAllocUnsafe = __webpack_require__(/*! ../lib/utils */ \"./node_modules/websocket/lib/utils.js\").bufferAllocUnsafe;\n\nmodule.exports = BufferList;\nmodule.exports.BufferList = BufferList; // backwards compatibility\n\nfunction BufferList(opts) {\n    if (!(this instanceof BufferList)) return new BufferList(opts);\n    EventEmitter.call(this);\n    var self = this;\n    \n    if (typeof(opts) == 'undefined') opts = {};\n    \n    // default encoding to use for take(). Leaving as 'undefined'\n    // makes take() return a Buffer instead.\n    self.encoding = opts.encoding;\n    \n    var head = { next : null, buffer : null };\n    var last = { next : null, buffer : null };\n    \n    // length can get negative when advanced past the end\n    // and this is the desired behavior\n    var length = 0;\n    self.__defineGetter__('length', function () {\n        return length;\n    });\n    \n    // keep an offset of the head to decide when to head = head.next\n    var offset = 0;\n    \n    // Write to the bufferlist. Emits 'write'. Always returns true.\n    self.write = function (buf) {\n        if (!head.buffer) {\n            head.buffer = buf;\n            last = head;\n        }\n        else {\n            last.next = { next : null, buffer : buf };\n            last = last.next;\n        }\n        length += buf.length;\n        self.emit('write', buf);\n        return true;\n    };\n    \n    self.end = function (buf) {\n        if (Buffer.isBuffer(buf)) self.write(buf);\n    };\n    \n    // Push buffers to the end of the linked list. (deprecated)\n    // Return this (self).\n    self.push = function () {\n        var args = [].concat.apply([], arguments);\n        args.forEach(self.write);\n        return self;\n    };\n    \n    // For each buffer, perform some action.\n    // If fn's result is a true value, cut out early.\n    // Returns this (self).\n    self.forEach = function (fn) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        \n        if (head.buffer.length - offset <= 0) return self;\n        var firstBuf = head.buffer.slice(offset);\n        \n        var b = { buffer : firstBuf, next : head.next };\n        \n        while (b && b.buffer) {\n            var r = fn(b.buffer);\n            if (r) break;\n            b = b.next;\n        }\n        \n        return self;\n    };\n    \n    // Create a single Buffer out of all the chunks or some subset specified by\n    // start and one-past the end (like slice) in bytes.\n    self.join = function (start, end) {\n        if (!head.buffer) return bufferAllocUnsafe(0);\n        if (start == undefined) start = 0;\n        if (end == undefined) end = self.length;\n        \n        var big = bufferAllocUnsafe(end - start);\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (start < (ix + buffer.length) && ix < end) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(0, ix - start),\n                    Math.max(0, start - ix),\n                    Math.min(buffer.length, end - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > end) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    self.joinInto = function (targetBuffer, targetStart, sourceStart, sourceEnd) {\n        if (!head.buffer) return new bufferAllocUnsafe(0);\n        if (sourceStart == undefined) sourceStart = 0;\n        if (sourceEnd == undefined) sourceEnd = self.length;\n        \n        var big = targetBuffer;\n        if (big.length - targetStart < sourceEnd - sourceStart) {\n            throw new Error(\"Insufficient space available in target Buffer.\");\n        }\n        var ix = 0;\n        self.forEach(function (buffer) {\n            if (sourceStart < (ix + buffer.length) && ix < sourceEnd) {\n                // at least partially contained in the range\n                buffer.copy(\n                    big,\n                    Math.max(targetStart, targetStart + ix - sourceStart),\n                    Math.max(0, sourceStart - ix),\n                    Math.min(buffer.length, sourceEnd - ix)\n                );\n            }\n            ix += buffer.length;\n            if (ix > sourceEnd) return true; // stop processing past end\n        });\n        \n        return big;\n    };\n    \n    // Advance the buffer stream by n bytes.\n    // If n the aggregate advance offset passes the end of the buffer list,\n    // operations such as .take() will return empty strings until enough data is\n    // pushed.\n    // Returns this (self).\n    self.advance = function (n) {\n        offset += n;\n        length -= n;\n        while (head.buffer && offset >= head.buffer.length) {\n            offset -= head.buffer.length;\n            head = head.next\n                ? head.next\n                : { buffer : null, next : null }\n            ;\n        }\n        if (head.buffer === null) last = { next : null, buffer : null };\n        self.emit('advance', n);\n        return self;\n    };\n    \n    // Take n bytes from the start of the buffers.\n    // Returns a string.\n    // If there are less than n bytes in all the buffers or n is undefined,\n    // returns the entire concatenated buffer string.\n    self.take = function (n, encoding) {\n        if (n == undefined) n = self.length;\n        else if (typeof n !== 'number') {\n            encoding = n;\n            n = self.length;\n        }\n        var b = head;\n        if (!encoding) encoding = self.encoding;\n        if (encoding) {\n            var acc = '';\n            self.forEach(function (buffer) {\n                if (n <= 0) return true;\n                acc += buffer.toString(\n                    encoding, 0, Math.min(n,buffer.length)\n                );\n                n -= buffer.length;\n            });\n            return acc;\n        } else {\n            // If no 'encoding' is specified, then return a Buffer.\n            return self.join(0, n);\n        }\n    };\n    \n    // The entire concatenated buffer as a string.\n    self.toString = function () {\n        return self.take('binary');\n    };\n}\n__webpack_require__(/*! util */ \"util\").inherits(BufferList, EventEmitter);\n\n\n//# sourceURL=webpack://NATS/./node_modules/websocket/vendor/FastBufferList.js?");

/***/ }),

/***/ "./node_modules/yaeti/index.js":
/*!*************************************!*\
  !*** ./node_modules/yaeti/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = {\n\tEventTarget : __webpack_require__(/*! ./lib/EventTarget */ \"./node_modules/yaeti/lib/EventTarget.js\"),\n\tEvent       : __webpack_require__(/*! ./lib/Event */ \"./node_modules/yaeti/lib/Event.js\")\n};\n\n\n//# sourceURL=webpack://NATS/./node_modules/yaeti/index.js?");

/***/ }),

/***/ "./node_modules/yaeti/lib/Event.js":
/*!*****************************************!*\
  !*** ./node_modules/yaeti/lib/Event.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Expose the Event class.\n */\nmodule.exports = _Event;\n\n\nfunction _Event(type) {\n\tthis.type = type;\n\tthis.isTrusted = false;\n\n\t// Set a flag indicating this is not a DOM Event object\n\tthis._yaeti = true;\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/yaeti/lib/Event.js?");

/***/ }),

/***/ "./node_modules/yaeti/lib/EventTarget.js":
/*!***********************************************!*\
  !*** ./node_modules/yaeti/lib/EventTarget.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/**\n * Expose the _EventTarget class.\n */\nmodule.exports = _EventTarget;\n\nfunction _EventTarget() {\n\t// Do nothing if called for a native EventTarget object..\n\tif (typeof this.addEventListener === 'function') {\n\t\treturn;\n\t}\n\n\tthis._listeners = {};\n\n\tthis.addEventListener = _addEventListener;\n\tthis.removeEventListener = _removeEventListener;\n\tthis.dispatchEvent = _dispatchEvent;\n}\n\nObject.defineProperties(_EventTarget.prototype, {\n\tlisteners: {\n\t\tget: function () {\n\t\t\treturn this._listeners;\n\t\t}\n\t}\n});\n\nfunction _addEventListener(type, newListener) {\n\tvar\n\t\tlistenersType,\n\t\ti, listener;\n\n\tif (!type || !newListener) {\n\t\treturn;\n\t}\n\n\tlistenersType = this._listeners[type];\n\tif (listenersType === undefined) {\n\t\tthis._listeners[type] = listenersType = [];\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (listener === newListener) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tlistenersType.push(newListener);\n}\n\nfunction _removeEventListener(type, oldListener) {\n\tvar\n\t\tlistenersType,\n\t\ti, listener;\n\n\tif (!type || !oldListener) {\n\t\treturn;\n\t}\n\n\tlistenersType = this._listeners[type];\n\tif (listenersType === undefined) {\n\t\treturn;\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (listener === oldListener) {\n\t\t\tlistenersType.splice(i, 1);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (listenersType.length === 0) {\n\t\tdelete this._listeners[type];\n\t}\n}\n\nfunction _dispatchEvent(event) {\n\tvar\n\t\ttype,\n\t\tlistenersType,\n\t\tdummyListener,\n\t\tstopImmediatePropagation = false,\n\t\ti, listener;\n\n\tif (!event || typeof event.type !== 'string') {\n\t\tthrow new Error('`event` must have a valid `type` property');\n\t}\n\n\t// Do some stuff to emulate DOM Event behavior (just if this is not a\n\t// DOM Event object)\n\tif (event._yaeti) {\n\t\tevent.target = this;\n\t\tevent.cancelable = true;\n\t}\n\n\t// Attempt to override the stopImmediatePropagation() method\n\ttry {\n\t\tevent.stopImmediatePropagation = function () {\n\t\t\tstopImmediatePropagation = true;\n\t\t};\n\t} catch (error) {}\n\n\ttype = event.type;\n\tlistenersType = (this._listeners[type] || []);\n\n\tdummyListener = this['on' + type];\n\tif (typeof dummyListener === 'function') {\n\t\tdummyListener.call(this, event);\n\t}\n\n\tfor (i = 0; !!(listener = listenersType[i]); i++) {\n\t\tif (stopImmediatePropagation) {\n\t\t\tbreak;\n\t\t}\n\n\t\tlistener.call(this, event);\n\t}\n\n\treturn !event.defaultPrevented;\n}\n\n\n//# sourceURL=webpack://NATS/./node_modules/yaeti/lib/EventTarget.js?");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"buffer\");\n\n//# sourceURL=webpack://NATS/external_%22buffer%22?");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"crypto\");\n\n//# sourceURL=webpack://NATS/external_%22crypto%22?");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"events\");\n\n//# sourceURL=webpack://NATS/external_%22events%22?");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"fs\");\n\n//# sourceURL=webpack://NATS/external_%22fs%22?");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"http\");\n\n//# sourceURL=webpack://NATS/external_%22http%22?");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"https\");\n\n//# sourceURL=webpack://NATS/external_%22https%22?");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"net\");\n\n//# sourceURL=webpack://NATS/external_%22net%22?");

/***/ }),

/***/ "tty":
/*!**********************!*\
  !*** external "tty" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"tty\");\n\n//# sourceURL=webpack://NATS/external_%22tty%22?");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"url\");\n\n//# sourceURL=webpack://NATS/external_%22url%22?");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = require(\"util\");\n\n//# sourceURL=webpack://NATS/external_%22util%22?");

/***/ })

/******/ });